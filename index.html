<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Optymalizator Zasobów i Produkcji</title>

    <!-- Biblioteki zewnętrzne -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/9.4.4/math.js"></script>
    <script src="https://cdn.plot.ly/plotly-2.24.1.min.js"></script>
    <script src="solver.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    
    <style>
        :root {
            --dark-brown: #4A3C31;
            --medium-brown: #785E45;
            --light-brown: #BFA58E;
            --gold: #D4AF37;
            --cream: #F5E6D3;
            --white: #FFFFFF;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            background-color: var(--cream);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .container {
            max-width: 1400px;
            margin: 20px auto;
            padding: 20px;
            background-color: var(--cream);
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.1);
            border-radius: 10px;
            flex-grow: 1;
        }

        header {
            background-color: var(--dark-brown);
            color: var(--white);
            padding: 1rem 0;
            text-align: center;
            border-bottom: 4px solid var(--gold);
        }

        nav {
            background-color: var(--medium-brown);
            padding: 0.5rem 0;
        }

        nav ul {
            list-style: none;
            padding: 0;
            margin: 0;
            display: flex;
            justify-content: center;
            gap: 1rem;
        }

        nav button {
            background: none;
            border: none;
            color: var(--white);
            padding: 0.5rem 1rem;
            cursor: pointer;
            transition: background-color 0.3s;
            border-radius: 5px;
        }

        nav button:hover, nav button.active {
            background-color: var(--dark-brown);
        }

        .tool-content {
            display: none;
            padding: 20px;
            background-color: var(--cream);
            border-radius: 8px;
            margin-top: 20px;
        }

        .tool-content.active {
            display: block;
        }

        .input-group {
            margin-bottom: 15px;
            padding: 15px;
            border: 1px solid var(--light-brown);
            border-radius: 8px;
            background-color: var(--cream);
        }

        .input-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
            flex-wrap: wrap; /* Dodane: umożliwia zawijanie elementów */
        }

        input[type="number"],
        input[type="text"],
        select {
            padding: 8px;
            border: 1px solid var(--light-brown);
            border-radius: 4px;
            width: 150px;
            background-color: var(--white);
        }

        input[type="number"]:focus,
        input[type="text"]:focus,
        select:focus {
            outline: none;
            border-color: var(--medium-brown);
            box-shadow: 0 0 0 2px rgba(120, 94, 69, 0.2);
        }

        button {
            background-color: var(--medium-brown);
            color: var(--white);
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        button:hover {
            background-color: var(--dark-brown);
        }

        .results {
            margin-top: 20px;
            padding: 15px;
            background-color: var(--cream);
            border-radius: 8px;
            white-space: pre-wrap;
            font-family: monospace;
        }

        #visualization {
            width: 100%;
            height: 500px;
            margin-top: 20px;
            border: 1px solid var(--light-brown);
            border-radius: 8px;
        }

        .error {
            color: #dc3545;
            padding: 10px;
            margin: 10px 0;
            border: 1px solid #dc3545;
            border-radius: 4px;
            background-color: #f8d7da;
        }

        .success {
            color: #28a745;
            padding: 10px;
            margin: 10px 0;
            border: 1px solid #28a745;
            border-radius: 4px;
            background-color: #d4edda;
        }

        .comparison-matrix {
            border-collapse: collapse;
            margin: 20px 0;
            background-color: var(--cream);
        }

        .comparison-matrix th,
        .comparison-matrix td {
            border: 1px solid var(--light-brown);
            padding: 8px;
            text-align: center;
        }

        .comparison-matrix th {
            background-color: var(--cream);
            font-weight: bold;
        }

        .comparison-matrix select {
            width: 100px;
            padding: 4px;
        }

        .visualization-container {
            width: 100%;
            height: 400px;
            margin-top: 20px;
        }
        
        /* Style dla ulepszonych wyników AHP */
        .results-table-container {
            margin: 20px 0;
            padding: 15px;
            background-color: var(--cream);
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        
        .final-results {
            border-left: 5px solid var(--medium-brown);
            background-color: #f4ead5;
        }
        
        .cr-warning {
            color: #dc3545;
            padding: 8px;
            margin: 10px 0;
            border-left: 4px solid #dc3545;
            background-color: #f8d7da;
            font-weight: bold;
        }
        
        .cr-ok {
            color: #28a745;
            padding: 8px;
            margin: 10px 0;
            border-left: 4px solid #28a745;
            background-color: #d4edda;
            font-weight: bold;
        }
        
        .results-interpretation {
            margin-top: 20px;
            padding: 10px;
            background-color: var(--cream);
            border-radius: 5px;
            border: 1px solid var(--light-brown);
        }
        
        .chart-legend {
            margin-top: 10px;
            font-size: 0.9em;
        }
        
        .legend-item {
            display: inline-block;
            width: 15px;
            height: 15px;
            margin-right: 5px;
        }
        
        .legend-item.best {
            color: rgba(46, 139, 87, 0.8);
        }
        
        .legend-item.other {
            color: rgba(70, 130, 180, 0.8);
        }
        
        .best-option {
            background-color: rgba(46, 139, 87, 0.1);
            font-weight: bold;
        }
        
        .final-score {
            font-weight: bold;
            background-color: rgba(212, 175, 55, 0.1);
        }
        
        .results-breakdown th[title],
        .results-breakdown td[title] {
            cursor: help;
        }
        
        /* Style dla głownego wyniku na górze */
        .main-result {
            background-color: var(--cream);
            border-left: 5px solid #2e8b57;
            padding: 20px;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
            margin-bottom: 30px;
        }
        
        .best-option-display {
            display: flex;
            align-items: center;
            margin: 15px 0;
            padding: 10px;
            background-color: rgba(46, 139, 87, 0.1);
            border-radius: 5px;
        }
        
        .best-option-label {
            font-size: 1.2em;
            font-weight: bold;
            margin-right: 15px;
            color: #333;
        }
        
        .best-option-name {
            font-size: 1.8em;
            font-weight: bold;
            color: #2e8b57;
            margin-right: 20px;
            flex-grow: 1;
        }
        
        .best-option-score {
            font-size: 1.5em;
            font-weight: bold;
            background-color: #2e8b57;
            color: white;
            padding: 8px 15px;
            border-radius: 5px;
        }
        
        .comparison-info {
            padding: 10px;
            background-color: #f0f0f0;
            border-left: 3px solid #666;
            margin: 10px 0;
            font-size: 0.95em;
        }
        
        /* Style dla wykresów z wkładem kryteriów */
        .criteria-contribution {
            margin: 20px 0;
            padding: 15px;
            background-color: white;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        
        .contribution-bars {
            margin-top: 15px;
        }
        
        .contribution-bar-container {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            cursor: help;
        }
        
        .contribution-label {
            width: 120px;
            padding-right: 10px;
            text-align: right;
            font-weight: bold;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .contribution-bar {
            flex-grow: 1;
            height: 25px;
            background-color: #f0f0f0;
            border-radius: 3px;
            overflow: hidden;
        }
        
        .contribution-fill {
            height: 100%;
            background-color: #2e8b57;
            color: white;
            display: flex;
            align-items: center;
            padding-left: 10px;
            font-weight: bold;
        }
        
        .best-option-local {
            background-color: rgba(70, 130, 180, 0.1);
            font-weight: bold;
        }
        
        .chart-with-legend {
            margin-bottom: 30px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }
        
        .color-info {
            color: #666;
            font-style: italic;
            margin-top: 10px;
             text-align: center;
         }

        /* Dodatkowe style dla responsywności */
        @media (max-width: 768px) {
            .input-row {
                flex-direction: column;
                align-items: stretch;
            }

            input[type="number"],
            input[type="text"],
            select {
                width: 100%;
                margin-bottom: 5px;
            }

            .comparison-matrix {
                font-size: 14px;
            }

            .comparison-matrix select {
                width: 80px;
            }
        }

        .loading-indicator {
            text-align: center;
            padding: 20px;
            margin: 20px auto;
            background-color: var(--cream);
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }
        
        .spinner {
            border: 5px solid var(--light-brown);
            border-top: 5px solid var(--dark-brown);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px auto;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Style dla modułu optymalizacji produkcji */
        .production-container {
            display: flex;
            gap: 20px;
            margin-top: 20px;
            flex-wrap: wrap; /* Dodane: umożliwia zawijanie przy mniejszych ekranach */
        }
        
        .production-sidebar {
            flex: 1;
            min-width: 320px;
            max-width: 450px;
        }
        
        .production-results {
            flex: 2;
            background-color: var(--cream);
            border-radius: 10px;
            padding: 20px;
            min-height: 400px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            height: 100%;
            display: flex;
            flex-direction: column;
        }
        
        .results-header {
            border-bottom: 2px solid var(--medium-brown);
            margin-bottom: 15px;
            padding-bottom: 10px;
        }
        
        .results-summary {
            background-color: var(--white);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .results-detail {
            background-color: var(--white);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            max-height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
            font-family: monospace;
            flex-grow: 1;
        }
        
        .visualization-container {
            background-color: var(--white);
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            min-height: 300px;
            width: 100%;
            margin-top: auto;
        }
        
        .constraints-description {
            background-color: rgba(255, 255, 255, 0.5);
            border-radius: 5px;
            padding: 10px;
            margin-bottom: 10px;
            font-size: 0.9em;
        }
        
        .constraints-description ul {
            margin: 5px 0 5px 20px;
            padding: 0;
        }
        
        .constraints-description li {
            margin-bottom: 3px;
        }
        
        .calculate-button {
            width: 100%;
            background-color: var(--dark-brown);
            color: var(--white);
            padding: 12px;
            font-size: 1.1em;
            margin-top: 20px;
            transition: background-color 0.3s;
            border-radius: 5px;
        }
        
        .calculate-button:hover {
            background-color: #3A2F28;
        }
        
        .add-constraint-button {
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-top: 10px;
            background-color: var(--light-brown);
            padding: 8px 12px;
            border-radius: 5px;
            transition: background-color 0.3s;
        }
        
        .add-constraint-button:hover {
            background-color: var(--medium-brown);
        }
        
        .add-constraint-button span {
            font-size: 16px;
            font-weight: bold;
        }
        
        .small-button {
            padding: 5px 10px;
            font-size: 0.8em;
            width: auto;
            min-width: 60px;
        }
        
        /* Tabela wyników optymalizacji */
        .optimization-results-table {
            width: 100%;
            border-collapse: collapse;
            margin: 10px 0;
        }
        
        .optimization-results-table th,
        .optimization-results-table td {
            border: 1px solid var(--light-brown);
            padding: 8px;
            text-align: center;
        }
        
        .optimization-results-table th {
            background-color: var(--medium-brown);
            color: var(--white);
        }
        
        .optimization-results-table tr:nth-child(even) {
            background-color: var(--cream);
        }
        
        .optimization-results-table .optimal-value {
            font-weight: bold;
            color: var(--dark-brown);
        }
        
        /* Styl dla constraintów */
        .constraint-container {
            background-color: rgba(255, 255, 255, 0.7);
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 10px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        
        .constraint-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-weight: bold;
            color: var(--dark-brown);
        }
        
        @media (max-width: 992px) {
            .production-container {
                flex-direction: column;
            }
            
            .production-sidebar,
            .production-results {
                max-width: 100%;
                width: 100%;
            }
            
            .production-results {
                min-height: 300px;
                margin-top: 20px;
            }
            
            .constraint-inputs {
                flex-direction: column;
                align-items: stretch;
            }
            
            .constraint-input, 
            .constraint-operator, 
            .constraint-rhs {
                width: 100%;
                max-width: 100%;
            }
        }

        /* Nowe style dla funkcji celu */
        .objective-function-container {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 8px;
            margin-top: 10px;
        }

        .obj-coefficient {
            width: 80px;
            flex-shrink: 0;
        }

        .obj-variable {
            margin-right: 10px;
        }

        @media (max-width: 576px) {
            .objective-function-container {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .obj-coefficient {
                width: 100%;
                margin-bottom: 5px;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>Optymalizator Zasobów i Produkcji</h1>
    </header>

    <nav>
        <ul>
            <li><button id="nav-ahp" onclick="App.switchToTool('ahp')">Kalkulator AHP</button></li>
            <li><button id="nav-cutting-stock" onclick="App.switchToTool('cutting-stock')">Problem Rozkroju</button></li>
            <li><button id="nav-production-opt" onclick="App.switchToTool('production-opt')">Optymalizacja Produkcji</button></li>
        </ul>
    </nav>

    <div class="container">
        <!-- AHP Calculator -->
        <div id="tool-ahp" class="tool-content">
            <h2>Kalkulator AHP</h2>
            <div class="input-group">
                <label>Liczba kryteriów (3-6):</label>
                <input type="number" id="ahpNumCriteria" min="3" max="6" value="3">
                <button onclick="AHP.setupInputs()">Ustaw kryteria</button>
            </div>
                    <div id="ahpCriteriaNames"></div>
            <div id="ahpCriteriaComparisonMatrix"></div>
                     <div id="ahpOptionNames"></div>
            <div id="ahpOptionsComparisonSection"></div>
            <div id="ahpResults" class="results"></div>
            <div id="ahpVisualization" class="visualization-container"></div>
                 </div>

        <!-- Cutting Stock Problem -->
        <div id="tool-cutting-stock" class="tool-content">
            <h2>Problem Rozkroju</h2>
                <div class="input-group">
                <div class="input-row">
                    <label>Długość kłody (m):</label>
                    <input type="number" id="logLength" value="2.0" step="0.1">
                </div>
                <div class="input-row">
                    <label>Dokładna liczba sztuk:</label>
                    <input type="checkbox" id="exactCuts">
                </div>
                <div id="ordersList"></div>
                <button onclick="CuttingStock.addOrderRow()">Dodaj zamówienie</button>
            </div>
            <button onclick="CuttingStock.calculate()">Oblicz optymalny podział</button>
            <div id="cuttingStockResults" class="tool-content"></div>
            <div id="cuttingStockVisualization" class="tool-content"></div>
            <div id="cuttingStockLoadingIndicator" class="loading-indicator" style="display: none;">
                <div class="spinner"></div>
                <p>Trwa obliczanie optymalnego rozwiązania...</p>
            </div>
        </div>

        <!-- Production Optimization -->
        <div id="tool-production-opt" class="tool-content">
            <h2>Optymalizacja Produkcji</h2>
            <div class="production-container">
                <div class="production-sidebar">
                    <div class="input-group">
                        <h3>Ustawienia</h3>
                        <div class="input-row">
                            <label for="numVars">Liczba produktów/zmiennych:</label>
                            <input type="number" id="numVars" min="1" max="10" value="2">
                            <button onclick="ProductionOpt.updateObjectiveFunction()" class="small-button">Zastosuj</button>
                        </div>
                        <div class="input-row">
                            <label for="optimizationType">Typ optymalizacji:</label>
                            <select id="optimizationType">
                                <option value="max">Maksymalizacja (zysk)</option>
                                <option value="min">Minimalizacja (koszty)</option>
                            </select>
                        </div>
                        <div class="input-row">
                            <label for="productNames">Nazwy produktów (oddzielone przecinkami):</label>
                            <input type="text" id="productNames" placeholder="Produkt A, Produkt B, ...">
                            <button onclick="ProductionOpt.applyProductNames()" class="small-button">Zastosuj</button>
                        </div>
                    </div>
                    
                    <div class="input-group">
                        <h3>Funkcja celu (zyski/koszty jednostkowe)</h3>
                        <div id="objectiveFunction"></div>
                    </div>
                    
                    <div class="input-group">
                        <h3>Ograniczenia</h3>
                        <div class="constraints-description">
                            <p>Przykłady ograniczeń:</p>
                            <ul>
                                <li>Maksymalna dostępność surowców</li>
                                <li>Ograniczenia czasowe maszyn</li>
                                <li>Minimalne/maksymalne ilości produktów</li>
                                <li>Ograniczenia budżetowe</li>
                            </ul>
                        </div>
                        <div id="constraints"></div>
                        <button onclick="ProductionOpt.addConstraint()" class="add-constraint-button">
                            <span>+</span> Dodaj ograniczenie
                        </button>
                    </div>
                    
                    <button onclick="ProductionOpt.calculate()" class="calculate-button">Oblicz optimum</button>
                </div>
                
                <div class="production-results">
                    <div class="results-header">
                        <h3>Wyniki Optymalizacji</h3>
                    </div>
                    
                    <div id="productionOptSummary" style="display: none;" class="results-summary">
                        <h4>Podsumowanie</h4>
                        <div id="productionOptSummaryContent"></div>
                    </div>
                    
                    <div id="productionOptResults" class="results-detail"></div>
                    <div id="productionOptVisualization" class="visualization-container"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- Global Namespace ---
        const Utils = {
            showElement: (id) => {
                const element = document.getElementById(id);
                if (element) {
                    element.style.display = 'block';
                }
            },
            
            hideElement: (id) => {
                const element = document.getElementById(id);
                if (element) {
                    element.style.display = 'none';
                }
            },
            
            clearElement: (id) => {
                const element = document.getElementById(id);
                if (element) {
                    element.innerHTML = '';
                }
            },
            
            displayResults: (containerId, content, isError = false) => {
                const container = document.getElementById(containerId);
                if (container) {
                    container.innerHTML = isError ? 
                        `<div class="error-message">${content}</div>` : 
                        content;
                    container.style.display = 'block';
                }
            },
            
            displayError: (message) => {
                // Tworzymy element div z komunikatem błędu
                const errorDiv = document.createElement('div');
                errorDiv.className = 'error-message';
                errorDiv.innerHTML = `
                    <div class="error-icon">⚠️</div>
                    <div class="error-content">
                        <h4>Wystąpił błąd</h4>
                        <p>${message}</p>
                    </div>
                `;
                
                // Znajdź kontener do wyświetlenia błędu na podstawie aktywnego narzędzia
                let containerId = 'ahpResults'; // Domyślny kontener
                
                if (document.getElementById('tool-cutting-stock').style.display === 'block') {
                    containerId = 'cuttingStockResults';
                } else if (document.getElementById('tool-production-opt').style.display === 'block') {
                    containerId = 'productionOptResults';
                }
                
                // Wyświetl błąd w odpowiednim kontenerze
                const container = document.getElementById(containerId);
                if (container) {
                    container.innerHTML = '';
                    container.appendChild(errorDiv);
                    container.style.display = 'block';
                }
                
                // Dodajemy style dla komunikatów o błędach
                if (!document.getElementById('error-styles')) {
                    const styleElement = document.createElement('style');
                    styleElement.id = 'error-styles';
                    styleElement.textContent = `
                        .error-message {
                            background-color: #FEE7E7;
                            border-left: 5px solid #D53636;
                            padding: 15px;
                            margin: 15px 0;
                            border-radius: 5px;
                            display: flex;
                            align-items: flex-start;
                        }
                        
                        .error-icon {
                            font-size: 24px;
                            margin-right: 15px;
                        }
                        
                        .error-content {
                            flex: 1;
                        }
                        
                        .error-content h4 {
                            margin: 0 0 5px 0;
                            color: #D53636;
                        }
                        
                        .error-content p {
                            margin: 0;
                            color: #333;
                        }
                    `;
                    document.head.appendChild(styleElement);
                }
            }
        };

        const App = {
            currentTool: null,

            switchToTool: (toolId) => {
                console.log(`--- Attempting to switch to tool: ${toolId} ---`);

                // Deactivate previous tool button and content
                if (App.currentTool) {
                    const previousToolContentId = `tool-${App.currentTool}`;
                    const previousNavButtonId = `nav-${App.currentTool}`;
                    console.log(`Hiding previous content: ${previousToolContentId}`);
                    Utils.hideElement(previousToolContentId);

                    const previousNavButton = document.getElementById(previousNavButtonId);
                    if (previousNavButton) {
                        previousNavButton.classList.remove('active');
                        console.log(`Deactivated nav button: ${previousNavButtonId}`);
                    } else {
                        console.warn(`Previous nav button not found: ${previousNavButtonId}`);
                    }
                } else {
                    console.log("No previous tool to deactivate.");
                }

                // Activate new tool button and content
                App.currentTool = toolId;
                const currentToolContentId = `tool-${toolId}`;
                const currentNavButtonId = `nav-${toolId}`;

                console.log(`Showing current content: ${currentToolContentId}`);
                Utils.showElement(currentToolContentId);

                const currentNavButton = document.getElementById(currentNavButtonId);
                if (currentNavButton) {
                    currentNavButton.classList.add('active');
                    console.log(`Activated nav button: ${currentNavButtonId}`);
                } else {
                    console.warn(`Current nav button not found: ${currentNavButtonId}`);
                }

                console.log(`Checking if init function exists for ${toolId}...`);
                // Initialize tool if needed
                try {
                    switch (toolId) {
                        case 'ahp':
                            if (typeof AHP !== 'undefined' && typeof AHP.init === 'function') {
                                console.log("Calling AHP.init()");
                                AHP.init();
                            } else { console.warn("AHP.init() not found"); }
                            break;
                        case 'cutting-stock':
                            if (typeof CuttingStock !== 'undefined' && typeof CuttingStock.init === 'function') {
                                console.log("Calling CuttingStock.init()");
                                CuttingStock.init();
                            } else { console.warn("CuttingStock.init() not found"); }
                            break;
                        case 'production-opt':
                            if (typeof ProductionOpt !== 'undefined' && typeof ProductionOpt.init === 'function') {
                                console.log("Calling ProductionOpt.init()");
                                ProductionOpt.init();
                            } else { console.warn("ProductionOpt.init() not found"); }
                            break;
                        default:
                            console.log(`No specific init function defined for tool: ${toolId}`);
                    }
                    console.log(`Initialization logic completed for ${toolId}.`);
                } catch (initError) {
                    console.error(`Error during init for tool ${toolId}:`, initError);
                    const resultsAreaId = `${toolId}Results`;
                    Utils.displayResults(resultsAreaId, `Error initializing tool: ${initError.message}. Check console.`, true);
                }
                console.log(`--- Switch to ${toolId} complete ---`);
            }
        };

        const AHP = {
            criteriaNames: [],
            optionNames: [],
            numCriteria: 0,
            numOptions: 0,
            criteriaComparisonMatrix: null,
            optionComparisonMatrices: null,
            criteriaPriorities: null,
            localOptionWeights: null,
            globalOptionWeights: null,
            RI: { 2: 0, 3: 0.52, 4: 0.89, 5: 1.11, 6: 1.25 },

            init: () => {
                console.log("Executing AHP.init()");
                Utils.hideElement('ahpResults');
                document.getElementById('ahpNumCriteria').value = '3';
            },

            setupInputs: () => {
                console.log("Setting up AHP inputs");
                AHP.numCriteria = parseInt(document.getElementById('ahpNumCriteria').value) || 3;
                
                if (AHP.numCriteria < 3 || AHP.numCriteria > 6) {
                    Utils.displayResults('ahpResults', 'Liczba kryteriów musi być między 3 a 6', true);
                    return;
                }
                
                // Przygotuj pola na nazwy kryteriów
                const criteriaContainer = document.getElementById('ahpCriteriaNames');
                criteriaContainer.innerHTML = '';
                criteriaContainer.className = 'input-group';
                
                const header = document.createElement('h3');
                header.textContent = 'Nazwy kryteriów';
                criteriaContainer.appendChild(header);
                
                for (let i = 0; i < AHP.numCriteria; i++) {
                    const inputRow = document.createElement('div');
                    inputRow.className = 'input-row';
                    
                    const label = document.createElement('label');
                    label.textContent = `Kryterium ${i+1}:`;
                    
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.id = `criteria-name-${i}`;
                    input.placeholder = `Kryterium ${i+1}`;
                    input.value = AHP.criteriaNames[i] || `Kryterium ${i+1}`;
                    
                    inputRow.appendChild(label);
                    inputRow.appendChild(input);
                    criteriaContainer.appendChild(inputRow);
                }
                
                // Dodaj przycisk do ustawienia liczby opcji
                const inputRow = document.createElement('div');
                inputRow.className = 'input-row';
                
                const label = document.createElement('label');
                label.textContent = 'Liczba opcji (2-6):';
                
                const input = document.createElement('input');
                input.type = 'number';
                input.id = 'ahpNumOptions';
                input.min = 2;
                input.max = 6;
                input.value = AHP.numOptions || 2;
                
                const button = document.createElement('button');
                button.textContent = 'Ustaw opcje';
                button.onclick = AHP.setupOptions;
                
                inputRow.appendChild(label);
                inputRow.appendChild(input);
                inputRow.appendChild(button);
                criteriaContainer.appendChild(inputRow);
                
                // Wyczyść matryce porównań i wyniki
                Utils.clearElement('ahpCriteriaComparisonMatrix');
                Utils.clearElement('ahpOptionNames');
                Utils.clearElement('ahpOptionsComparisonSection');
                Utils.hideElement('ahpResults');
                Utils.clearElement('ahpVisualization');
            },
            
            setupOptions: () => {
                console.log("Setting up AHP options");
                AHP.numOptions = parseInt(document.getElementById('ahpNumOptions').value) || 2;
                
                if (AHP.numOptions < 2 || AHP.numOptions > 6) {
                    Utils.displayResults('ahpResults', 'Liczba opcji musi być między 2 a 6', true);
                    return;
                }
                
                // Zapisz nazwy kryteriów
                AHP.criteriaNames = [];
                for (let i = 0; i < AHP.numCriteria; i++) {
                    const input = document.getElementById(`criteria-name-${i}`);
                    AHP.criteriaNames.push(input.value || `Kryterium ${i+1}`);
                }
                
                // Przygotuj macierz porównań dla kryteriów
                AHP.createCriteriaComparisonMatrix();
                
                // Przygotuj pola na nazwy opcji
                const optionsContainer = document.getElementById('ahpOptionNames');
                optionsContainer.innerHTML = '';
                optionsContainer.className = 'input-group';
                
                const header = document.createElement('h3');
                header.textContent = 'Nazwy opcji';
                optionsContainer.appendChild(header);
                
                for (let i = 0; i < AHP.numOptions; i++) {
                    const inputRow = document.createElement('div');
                    inputRow.className = 'input-row';
                    
                    const label = document.createElement('label');
                    label.textContent = `Opcja ${i+1}:`;
                    
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.id = `option-name-${i}`;
                    input.placeholder = `Opcja ${i+1}`;
                    input.value = AHP.optionNames[i] || `Opcja ${i+1}`;
                    
                    inputRow.appendChild(label);
                    inputRow.appendChild(input);
                    optionsContainer.appendChild(inputRow);
                }
                
                const button = document.createElement('button');
                button.textContent = 'Utwórz macierze porównań';
                button.onclick = AHP.setupOptionComparisons;
                optionsContainer.appendChild(button);
            },
            
            createCriteriaComparisonMatrix: () => {
                const container = document.getElementById('ahpCriteriaComparisonMatrix');
                container.innerHTML = '';
                
                const header = document.createElement('h3');
                header.textContent = 'Porównanie ważności kryteriów';
                container.appendChild(header);
                
                // Utwórz tabelę porównań
                const table = document.createElement('table');
                table.className = 'comparison-matrix';
                
                // Nagłówki kolumn
                const thead = document.createElement('thead');
                const headerRow = document.createElement('tr');
                
                // Pusta komórka w lewym górnym rogu
                headerRow.appendChild(document.createElement('th'));
                
                for (let i = 0; i < AHP.numCriteria; i++) {
                    const th = document.createElement('th');
                    th.textContent = AHP.criteriaNames[i];
                    headerRow.appendChild(th);
                }
                
                thead.appendChild(headerRow);
                table.appendChild(thead);
                
                // Ciało tabeli
                const tbody = document.createElement('tbody');
                
                for (let i = 0; i < AHP.numCriteria; i++) {
                    const row = document.createElement('tr');
                    
                    // Nagłówek wiersza
                    const th = document.createElement('th');
                    th.textContent = AHP.criteriaNames[i];
                    row.appendChild(th);
                    
                    for (let j = 0; j < AHP.numCriteria; j++) {
                        const td = document.createElement('td');
                        
                        if (i === j) {
                            // Przekątna = 1
                            td.textContent = '1';
                        } else if (i < j) {
                            // Górna część macierzy - wybór wartości
                            const select = document.createElement('select');
                            select.id = `criteria-comp-${i}-${j}`;
                            select.onchange = () => AHP.updateCriteriaComparisonValue(i, j);
                            
                            const values = [9, 8, 7, 6, 5, 4, 3, 2, 1, 1/2, 1/3, 1/4, 1/5, 1/6, 1/7, 1/8, 1/9];
                            const labels = ["9", "8", "7", "6", "5", "4", "3", "2", "1", "1/2", "1/3", "1/4", "1/5", "1/6", "1/7", "1/8", "1/9"];
                            
                            for (let k = 0; k < values.length; k++) {
                                const option = document.createElement('option');
                                option.value = values[k];
                                option.textContent = labels[k];
                                
                                if (values[k] === 1) {
                                    option.selected = true;
                                }
                                
                                select.appendChild(option);
                            }
                            
                            td.appendChild(select);
                        } else {
                            // Dolna część macierzy - odwrotność
                            td.id = `criteria-comp-value-${i}-${j}`;
                            td.textContent = '1';
                        }
                        
                        row.appendChild(td);
                    }
                    
                    tbody.appendChild(row);
                }
                
                table.appendChild(tbody);
                container.appendChild(table);
            },
            
            updateCriteriaComparisonValue: (i, j) => {
                const select = document.getElementById(`criteria-comp-${i}-${j}`);
                const value = parseFloat(select.value);
                const inverseCell = document.getElementById(`criteria-comp-value-${j}-${i}`);
                
                if (inverseCell) {
                    inverseCell.textContent = (1 / value).toFixed(4);
                }
            },
            
            setupOptionComparisons: () => {
                // Zapisz nazwy opcji
                AHP.optionNames = [];
                for (let i = 0; i < AHP.numOptions; i++) {
                    const input = document.getElementById(`option-name-${i}`);
                    AHP.optionNames.push(input.value || `Opcja ${i+1}`);
                }
                
                // Utwórz sekcję dla macierzy porównań opcji dla każdego kryterium
                const container = document.getElementById('ahpOptionsComparisonSection');
                container.innerHTML = '';
                
                for (let c = 0; c < AHP.numCriteria; c++) {
                    const criteriaSection = document.createElement('div');
                    criteriaSection.className = 'input-group';
                    
                    const header = document.createElement('h3');
                    header.textContent = `Porównanie opcji względem kryterium: ${AHP.criteriaNames[c]}`;
                    criteriaSection.appendChild(header);
                    
                    // Utwórz tabelę porównań dla tego kryterium
                    const table = document.createElement('table');
                    table.className = 'comparison-matrix';
                    
                    // Nagłówki kolumn
                    const thead = document.createElement('thead');
                    const headerRow = document.createElement('tr');
                    
                    // Pusta komórka w lewym górnym rogu
                    headerRow.appendChild(document.createElement('th'));
                    
                    for (let i = 0; i < AHP.numOptions; i++) {
                        const th = document.createElement('th');
                        th.textContent = AHP.optionNames[i];
                        headerRow.appendChild(th);
                    }
                    
                    thead.appendChild(headerRow);
                    table.appendChild(thead);
                    
                    // Ciało tabeli
                    const tbody = document.createElement('tbody');
                    
                    for (let i = 0; i < AHP.numOptions; i++) {
                        const row = document.createElement('tr');
                        
                        // Nagłówek wiersza
                        const th = document.createElement('th');
                        th.textContent = AHP.optionNames[i];
                        row.appendChild(th);
                        
                        for (let j = 0; j < AHP.numOptions; j++) {
                            const td = document.createElement('td');
                            
                            if (i === j) {
                                // Przekątna = 1
                                td.textContent = '1';
                            } else if (i < j) {
                                // Górna część macierzy - wybór wartości
                                const select = document.createElement('select');
                                select.id = `option-comp-${c}-${i}-${j}`;
                                select.onchange = () => AHP.updateOptionComparisonValue(c, i, j);
                                
                                const values = [9, 8, 7, 6, 5, 4, 3, 2, 1, 1/2, 1/3, 1/4, 1/5, 1/6, 1/7, 1/8, 1/9];
                                const labels = ["9", "8", "7", "6", "5", "4", "3", "2", "1", "1/2", "1/3", "1/4", "1/5", "1/6", "1/7", "1/8", "1/9"];
                                
                                for (let k = 0; k < values.length; k++) {
                                    const option = document.createElement('option');
                                    option.value = values[k];
                                    option.textContent = labels[k];
                                    
                                    if (values[k] === 1) {
                                        option.selected = true;
                                    }
                                    
                                    select.appendChild(option);
                                }
                                
                                td.appendChild(select);
                            } else {
                                // Dolna część macierzy - odwrotność
                                td.id = `option-comp-value-${c}-${i}-${j}`;
                                td.textContent = '1';
                            }
                            
                            row.appendChild(td);
                        }
                        
                        tbody.appendChild(row);
                    }
                    
                    table.appendChild(tbody);
                    criteriaSection.appendChild(table);
                    
                    container.appendChild(criteriaSection);
                }
                
                // Dodaj przycisk do obliczenia wyników
                const calculateButton = document.createElement('button');
                calculateButton.textContent = 'Oblicz wyniki';
                calculateButton.onclick = AHP.calculate;
                container.appendChild(calculateButton);
            },
            
            updateOptionComparisonValue: (c, i, j) => {
                const select = document.getElementById(`option-comp-${c}-${i}-${j}`);
                const value = parseFloat(select.value);
                const inverseCell = document.getElementById(`option-comp-value-${c}-${j}-${i}`);
                
                if (inverseCell) {
                    inverseCell.textContent = (1 / value).toFixed(4);
                }
            },
            
            calculate: () => {
                try {
                    // Budowa macierzy porównań kryteriów
                    AHP.criteriaComparisonMatrix = [];
                    for (let i = 0; i < AHP.numCriteria; i++) {
                        AHP.criteriaComparisonMatrix[i] = [];
                        for (let j = 0; j < AHP.numCriteria; j++) {
                            if (i === j) {
                                AHP.criteriaComparisonMatrix[i][j] = 1;
                            } else if (i < j) {
                                const select = document.getElementById(`criteria-comp-${i}-${j}`);
                                AHP.criteriaComparisonMatrix[i][j] = parseFloat(select.value);
                            } else {
                                AHP.criteriaComparisonMatrix[i][j] = 1 / AHP.criteriaComparisonMatrix[j][i];
                            }
                        }
                    }
                    
                    // Obliczenie priorytetów kryteriów
                    AHP.criteriaPriorities = AHP.calculatePriorities(AHP.criteriaComparisonMatrix);
                    
                    // Budowa macierzy porównań opcji
                    AHP.optionComparisonMatrices = [];
                    AHP.localOptionWeights = [];
                    
                    for (let c = 0; c < AHP.numCriteria; c++) {
                        const matrix = [];
                        for (let i = 0; i < AHP.numOptions; i++) {
                            matrix[i] = [];
                            for (let j = 0; j < AHP.numOptions; j++) {
                                if (i === j) {
                                    matrix[i][j] = 1;
                                } else if (i < j) {
                                    const select = document.getElementById(`option-comp-${c}-${i}-${j}`);
                                    matrix[i][j] = parseFloat(select.value);
                                } else {
                                    matrix[i][j] = 1 / matrix[j][i];
                                }
                            }
                        }
                        
                        AHP.optionComparisonMatrices.push(matrix);
                        AHP.localOptionWeights.push(AHP.calculatePriorities(matrix));
                    }
                    
                    // Obliczenie końcowych wag opcji
                    AHP.globalOptionWeights = Array(AHP.numOptions).fill(0);
                    
                    for (let i = 0; i < AHP.numOptions; i++) {
                        for (let c = 0; c < AHP.numCriteria; c++) {
                            AHP.globalOptionWeights[i] += AHP.localOptionWeights[c][i] * AHP.criteriaPriorities[c];
                        }
                    }
                    
                    // Wyświetl wyniki
                    AHP.displayResults();
                } catch (error) {
                    console.error("Error in AHP calculation:", error);
                    Utils.displayResults('ahpResults', `Błąd obliczenia: ${error.message}`, true);
                }
            },
            
            calculatePriorities: (matrix) => {
                // Metoda średniej geometrycznej (Saaty)
                const size = matrix.length;
                const priorities = Array(size).fill(0);
                
                // Obliczenie średniej geometrycznej dla każdego wiersza
                for (let i = 0; i < size; i++) {
                    let product = 1;
                    for (let j = 0; j < size; j++) {
                        product *= matrix[i][j];
                    }
                    priorities[i] = Math.pow(product, 1/size);
                }
                
                // Normalizacja
                const sum = priorities.reduce((acc, val) => acc + val, 0);
                for (let i = 0; i < size; i++) {
                    priorities[i] /= sum;
                }
                
                return priorities;
            },
            
            calculateConsistencyRatio: (matrix, weights) => {
                const size = matrix.length;
                if (size <= 2) return 0; // Dla 1 lub 2 elementów CR zawsze 0
                
                // Obliczenie λ max
                const weightedSumVector = [];
                for (let i = 0; i < size; i++) {
                    let sum = 0;
                    for (let j = 0; j < size; j++) {
                        sum += matrix[i][j] * weights[j];
                    }
                    weightedSumVector[i] = sum;
                }
                
                const consistencyVector = Array(size);
                
                for (let i = 0; i < size; i++) {
                    consistencyVector[i] = weightedSumVector[i] / weights[i];
                }
                
                const lambdaMax = consistencyVector.reduce((acc, val) => acc + val, 0) / size;
                
                // Obliczenie CI (Consistency Index)
                const CI = (lambdaMax - size) / (size - 1);
                
                // Obliczenie CR (Consistency Ratio)
                return CI / AHP.RI[size];
            },
            
            displayResults: () => {
                const resultsContainer = document.getElementById('ahpResults');
                resultsContainer.innerHTML = '';
                
                // Sortowanie opcji według priorytetów globalnych
                const sortedIndices = Array.from(Array(AHP.numOptions).keys())
                    .sort((a, b) => AHP.globalOptionWeights[b] - AHP.globalOptionWeights[a]);
                
                // NOWE: Najważniejszy wynik na górze
                const mainResult = document.createElement('div');
                mainResult.className = 'results-table-container main-result';
                
                const bestOption = AHP.optionNames[sortedIndices[0]];
                const bestScore = (AHP.globalOptionWeights[sortedIndices[0]] * 100).toFixed(2);
                
                const mainResultHeader = document.createElement('h2');
                mainResultHeader.textContent = 'Wynik analizy AHP';
                mainResult.appendChild(mainResultHeader);
                
                const bestOptionDisplay = document.createElement('div');
                bestOptionDisplay.className = 'best-option-display';
                bestOptionDisplay.innerHTML = `
                    <div class="best-option-label">Najlepsza opcja:</div>
                    <div class="best-option-name">${bestOption}</div>
                    <div class="best-option-score">Wynik: ${bestScore}%</div>
                `;
                mainResult.appendChild(bestOptionDisplay);
                
                // Różnica względem drugiej najlepszej opcji, jeśli jest więcej niż jedna opcja
                if (AHP.numOptions > 1) {
                    const secondBestScore = (AHP.globalOptionWeights[sortedIndices[1]] * 100).toFixed(2);
                    const difference = (bestScore - secondBestScore).toFixed(2);
                    const differencePercent = ((bestScore - secondBestScore) / secondBestScore * 100).toFixed(1);
                    
                    const comparisonInfo = document.createElement('div');
                    comparisonInfo.className = 'comparison-info';
                    comparisonInfo.innerHTML = `
                        <p>Przewaga nad drugą najlepszą opcją (${AHP.optionNames[sortedIndices[1]]}): 
                        <strong>${difference} punktów procentowych</strong> 
                        (${differencePercent}% lepsza)</p>
                    `;
                    mainResult.appendChild(comparisonInfo);
                }
                
                // Podgląd wkładu kryteriów w najlepszą opcję
                const criteriaContribution = document.createElement('div');
                criteriaContribution.className = 'criteria-contribution';
                
                const contributionHeader = document.createElement('h4');
                contributionHeader.textContent = 'Wkład poszczególnych kryteriów:';
                criteriaContribution.appendChild(contributionHeader);
                
                const contributionChart = document.createElement('div');
                contributionChart.className = 'contribution-bars';
                
                // Obliczanie wkładu każdego kryterium w wynik najlepszej opcji
                let totalContribution = 0;
                const contributions = [];
                
                for (let c = 0; c < AHP.numCriteria; c++) {
                    const bestOptionIdx = sortedIndices[0];
                    const localScore = AHP.localOptionWeights[c][bestOptionIdx];
                    const criteriaPriority = AHP.criteriaPriorities[c];
                    const contribution = localScore * criteriaPriority;
                    totalContribution += contribution;
                    
                    contributions.push({
                        criteriaName: AHP.criteriaNames[c],
                        contribution: contribution,
                        localScore: localScore,
                        criteriaPriority: criteriaPriority,
                        percent: (contribution / AHP.globalOptionWeights[bestOptionIdx] * 100)
                    });
                }
                
                // Sortuj kryteria według ich wkładu (od największego)
                contributions.sort((a, b) => b.contribution - a.contribution);
                
                for (const item of contributions) {
                    const barContainer = document.createElement('div');
                    barContainer.className = 'contribution-bar-container';
                    
                    const label = document.createElement('div');
                    label.className = 'contribution-label';
                    label.textContent = item.criteriaName;
                    
                    const bar = document.createElement('div');
                    bar.className = 'contribution-bar';
                    
                    const fill = document.createElement('div');
                    fill.className = 'contribution-fill';
                    fill.style.width = `${item.percent.toFixed(1)}%`;
                    fill.textContent = `${item.percent.toFixed(1)}%`;
                    
                    bar.appendChild(fill);
                    barContainer.appendChild(label);
                    barContainer.appendChild(bar);
                    contributionChart.appendChild(barContainer);
                }
                
                criteriaContribution.appendChild(contributionChart);
                mainResult.appendChild(criteriaContribution);
                
                resultsContainer.appendChild(mainResult);
                
                // Tworzenie tabelki z priorytetami kryteriów
                const criteriaTable = document.createElement('div');
                criteriaTable.className = 'results-table-container';
                
                const criteriaHeader = document.createElement('h3');
                criteriaHeader.textContent = 'Priorytety kryteriów';
                criteriaTable.appendChild(criteriaHeader);
                
                const table1 = document.createElement('table');
                table1.className = 'comparison-matrix';
                
                // Nagłówki kolumn
                const thead1 = document.createElement('thead');
                const headerRow1 = document.createElement('tr');
                
                const th1 = document.createElement('th');
                th1.textContent = 'Kryterium';
                headerRow1.appendChild(th1);
                
                const th2 = document.createElement('th');
                th2.textContent = 'Priorytet';
                headerRow1.appendChild(th2);
                
                const th3 = document.createElement('th');
                th3.textContent = 'Procent';
                headerRow1.appendChild(th3);
                
                thead1.appendChild(headerRow1);
                table1.appendChild(thead1);
                
                // Ciało tabeli
                const tbody1 = document.createElement('tbody');
                
                for (let i = 0; i < AHP.numCriteria; i++) {
                    const row = document.createElement('tr');
                    
                    const td1 = document.createElement('td');
                    td1.textContent = AHP.criteriaNames[i];
                    row.appendChild(td1);
                    
                    const td2 = document.createElement('td');
                    td2.textContent = AHP.criteriaPriorities[i].toFixed(4);
                    row.appendChild(td2);
                    
                    const td3 = document.createElement('td');
                    td3.textContent = `${(AHP.criteriaPriorities[i] * 100).toFixed(2)}%`;
                    row.appendChild(td3);
                    
                    tbody1.appendChild(row);
                }
                
                table1.appendChild(tbody1);
                criteriaTable.appendChild(table1);
                
                // Współczynnik spójności dla kryteriów
                const criteriaCR = AHP.calculateConsistencyRatio(AHP.criteriaComparisonMatrix, AHP.criteriaPriorities);
                
                const crInfo1 = document.createElement('div');
                crInfo1.className = criteriaCR > 0.1 ? 'cr-warning' : 'cr-ok';
                
                let crMessage1 = `Współczynnik spójności (CR): ${criteriaCR.toFixed(4)}`;
                if (criteriaCR > 0.1) {
                    crMessage1 += " - UWAGA: Wartość powyżej 0.1 sugeruje niespójność porównań!";
                } else {
                    crMessage1 += " - OK: Porównania są spójne.";
                }
                
                crInfo1.textContent = crMessage1;
                criteriaTable.appendChild(crInfo1);
                
                const crExplanation1 = document.createElement('p');
                crExplanation1.innerHTML = '<strong>Interpretacja CR:</strong> Współczynnik spójności (CR) mierzy, jak konsekwentne są porównania. Wartość poniżej 0.1 jest uważana za akceptowalną, wartości wyższe sugerują potrzebę rewizji porównań.';
                criteriaTable.appendChild(crExplanation1);
                
                resultsContainer.appendChild(criteriaTable);
                
                // Tworzenie sekcji wyników końcowych
                const finalTable = document.createElement('div');
                finalTable.className = 'results-table-container final-results';
                
                const finalHeader = document.createElement('h3');
                finalHeader.textContent = 'Wyniki końcowe';
                finalTable.appendChild(finalHeader);
                
                const table3 = document.createElement('table');
                table3.className = 'comparison-matrix';
                
                // Nagłówki kolumn
                const thead3 = document.createElement('thead');
                const headerRow3 = document.createElement('tr');
                
                const th7 = document.createElement('th');
                th7.textContent = 'Opcja';
                headerRow3.appendChild(th7);
                
                const th8 = document.createElement('th');
                th8.textContent = 'Priorytet globalny';
                headerRow3.appendChild(th8);
                
                const th9 = document.createElement('th');
                th9.textContent = 'Procent';
                headerRow3.appendChild(th9);
                
                thead3.appendChild(headerRow3);
                table3.appendChild(thead3);
                
                // Ciało tabeli
                const tbody3 = document.createElement('tbody');
                
                for (let i = 0; i < AHP.numOptions; i++) {
                    const idx = sortedIndices[i];
                    const row = document.createElement('tr');
                    
                    const td7 = document.createElement('td');
                    td7.textContent = AHP.optionNames[idx];
                    row.appendChild(td7);
                    
                    const td8 = document.createElement('td');
                    td8.textContent = AHP.globalOptionWeights[idx].toFixed(4);
                    row.appendChild(td8);
                    
                    const td9 = document.createElement('td');
                    td9.textContent = `${(AHP.globalOptionWeights[idx] * 100).toFixed(2)}%`;
                    row.appendChild(td9);
                    
                    if (i === 0) {
                        row.className = 'best-option';
                    }
                    
                    tbody3.appendChild(row);
                }
                
                table3.appendChild(tbody3);
                finalTable.appendChild(table3);
                
                // Dodaj interpretację wyników
                const interpretation = document.createElement('div');
                interpretation.className = 'results-interpretation';
                
                const interpretationTitle = document.createElement('h4');
                interpretationTitle.textContent = 'Interpretacja wyników:';
                interpretation.appendChild(interpretationTitle);
                
                const interpretationText = document.createElement('p');
                interpretationText.innerHTML = `
                    <strong>Najlepsza opcja: ${AHP.optionNames[sortedIndices[0]]}</strong> z wynikiem ${(AHP.globalOptionWeights[sortedIndices[0]] * 100).toFixed(2)}%.<br><br>
                    <strong>Jak czytać wyniki?</strong><br>
                    • Wartości procentowe pokazują względną ważność każdej opcji.<br>
                    • Im wyższy procent, tym lepsza opcja według podanych kryteriów i porównań.<br>
                    • Różnica między opcjami wskazuje na siłę preferencji jednej opcji nad drugą.<br><br>
                    <strong>Co dalej?</strong><br>
                    • Sprawdź, czy współczynniki spójności (CR) są poniżej 0.1 dla wszystkich porównań.<br>
                    • Jeśli CR > 0.1, rozważ poprawę porównań parami dla odpowiednich kryteriów lub opcji.<br>
                    • Wyniki są tak dobre, jak dokładne były twoje porównania - zweryfikuj je, jeśli wyniki wydają się nieoczekiwane.
                `;
                interpretation.appendChild(interpretationText);
                
                finalTable.appendChild(interpretation);
                resultsContainer.appendChild(finalTable);
                
                // Tworzenie sekcji priorytetów lokalnych opcji
                for (let c = 0; c < AHP.numCriteria; c++) {
                    const optionTable = document.createElement('div');
                    optionTable.className = 'results-table-container';
                    
                    const optionHeader = document.createElement('h3');
                    optionHeader.textContent = `Priorytety opcji dla kryterium: ${AHP.criteriaNames[c]}`;
                    optionTable.appendChild(optionHeader);
                    
                    const table2 = document.createElement('table');
                    table2.className = 'comparison-matrix';
                    
                    // Nagłówki kolumn
                    const thead2 = document.createElement('thead');
                    const headerRow2 = document.createElement('tr');
                    
                    const th4 = document.createElement('th');
                    th4.textContent = 'Opcja';
                    headerRow2.appendChild(th4);
                    
                    const th5 = document.createElement('th');
                    th5.textContent = 'Priorytet lokalny';
                    headerRow2.appendChild(th5);
                    
                    const th6 = document.createElement('th');
                    th6.textContent = 'Procent';
                    headerRow2.appendChild(th6);
                    
                    thead2.appendChild(headerRow2);
                    table2.appendChild(thead2);
                    
                    // Ciało tabeli
                    const tbody2 = document.createElement('tbody');
                    
                    // Sortowanie opcji według priorytetów lokalnych dla tego kryterium
                    const localSortedIndices = Array.from(Array(AHP.numOptions).keys())
                        .sort((a, b) => AHP.localOptionWeights[c][b] - AHP.localOptionWeights[c][a]);
                    
                    for (let i = 0; i < AHP.numOptions; i++) {
                        const idx = localSortedIndices[i];
                        const row = document.createElement('tr');
                        
                        const td4 = document.createElement('td');
                        td4.textContent = AHP.optionNames[idx];
                        row.appendChild(td4);
                        
                        const td5 = document.createElement('td');
                        td5.textContent = AHP.localOptionWeights[c][idx].toFixed(4);
                        row.appendChild(td5);
                        
                        const td6 = document.createElement('td');
                        td6.textContent = `${(AHP.localOptionWeights[c][idx] * 100).toFixed(2)}%`;
                        row.appendChild(td6);
                        
                        if (i === 0) {
                            row.className = 'best-option-local';
                        }
                        
                        tbody2.appendChild(row);
                    }
                    
                    table2.appendChild(tbody2);
                    optionTable.appendChild(table2);
                    
                    // Współczynnik spójności dla opcji
                    const optionCR = AHP.calculateConsistencyRatio(AHP.optionComparisonMatrices[c], AHP.localOptionWeights[c]);
                    
                    const crInfo2 = document.createElement('div');
                    crInfo2.className = optionCR > 0.1 ? 'cr-warning' : 'cr-ok';
                    
                    let crMessage2 = `Współczynnik spójności (CR): ${optionCR.toFixed(4)}`;
                    if (optionCR > 0.1) {
                        crMessage2 += " - UWAGA: Wartość powyżej 0.1 sugeruje niespójność porównań!";
            } else {
                        crMessage2 += " - OK: Porównania są spójne.";
                    }
                    
                    crInfo2.textContent = crMessage2;
                    optionTable.appendChild(crInfo2);
                    
                    resultsContainer.appendChild(optionTable);
                }
                
                // Dodaj tabelkę z rozbiciem na kryteria
                const breakdownContainer = document.createElement('div');
                breakdownContainer.className = 'results-table-container';
                breakdownContainer.style.marginTop = '30px';
                
                const breakdownTitle = document.createElement('h3');
                breakdownTitle.textContent = 'Rozbicie wyników według kryteriów';
                breakdownContainer.appendChild(breakdownTitle);
                
                const breakdownDescription = document.createElement('p');
                breakdownDescription.innerHTML = 'Tabela pokazuje, jak każda opcja wypada w poszczególnych kryteriach oraz jaki to ma wpływ na wynik końcowy.';
                breakdownContainer.appendChild(breakdownDescription);
                
                const breakdownTable = document.createElement('table');
                breakdownTable.className = 'comparison-matrix results-breakdown';
                
                // Nagłówki kolumn
                const bthead = document.createElement('thead');
                const bheaderRow = document.createElement('tr');
                
                const bth1 = document.createElement('th');
                bth1.textContent = 'Opcja';
                bheaderRow.appendChild(bth1);
                
                // Dodaj nagłówki dla każdego kryterium
                for (let c = 0; c < AHP.numCriteria; c++) {
                    const th = document.createElement('th');
                    th.textContent = AHP.criteriaNames[c];
                    bheaderRow.appendChild(th);
                }
                
                const bth2 = document.createElement('th');
                bth2.textContent = 'Wynik';
                bheaderRow.appendChild(bth2);
                
                bthead.appendChild(bheaderRow);
                breakdownTable.appendChild(bthead);
                
                // Ciało tabeli
                const btbody = document.createElement('tbody');
                
                for (let i = 0; i < AHP.numOptions; i++) {
                    const idx = sortedIndices[i];
                    const row = document.createElement('tr');
                    
                    const td1 = document.createElement('td');
                    td1.textContent = AHP.optionNames[idx];
                    row.appendChild(td1);
                    
                    // Dodaj komórki dla każdego kryterium z wartością lokalną
                    for (let c = 0; c < AHP.numCriteria; c++) {
                        const td = document.createElement('td');
                        const localValue = AHP.localOptionWeights[c][idx];
                        
                        td.textContent = `${(localValue * 100).toFixed(1)}%`;
                        
                        // Dodaj kolorowanie tła zależne od wartości
                        const intensity = Math.min(localValue * 2, 1);  // Ograniczenie intensywności do 1
                        td.style.backgroundColor = `rgba(70, 130, 180, ${intensity * 0.3})`;
                        
                        row.appendChild(td);
                    }
                    
                    const td2 = document.createElement('td');
                    td2.textContent = `${(AHP.globalOptionWeights[idx] * 100).toFixed(2)}%`;
                    td2.className = 'final-score';
                    
                    row.appendChild(td2);
                    
                    if (i === 0) {
                        row.className = 'best-option';
                    }
                    
                    btbody.appendChild(row);
                }
                
                breakdownTable.appendChild(btbody);
                breakdownContainer.appendChild(breakdownTable);
                
                // Dodaj informację o intensywności koloru
                const colorInfo = document.createElement('p');
                colorInfo.className = 'color-info';
                colorInfo.textContent = 'Intensywność niebieskiego koloru odzwierciedla wynik opcji w danym kryterium.';
                breakdownContainer.appendChild(colorInfo);
                
                resultsContainer.appendChild(breakdownContainer);
                
                // Pokaż wyniki
                Utils.showElement('ahpResults');
                
                // Wizualizacja wyników
                AHP.visualizeResults();
            },
            
            visualizeResults: () => {
                const container = document.getElementById('ahpVisualization');
                container.innerHTML = '';
                
                // Przygotuj dane do wykresu słupkowego
                const sortedIndices = Array.from(Array(AHP.numOptions).keys())
                    .sort((a, b) => AHP.globalOptionWeights[b] - AHP.globalOptionWeights[a]);
                
                const sortedLabels = sortedIndices.map(idx => AHP.optionNames[idx]);
                const sortedValues = sortedIndices.map(idx => AHP.globalOptionWeights[idx] * 100);
                
                // Kolorowanie słupków - najlepszy zielony, pozostałe niebieskie
                const colors = sortedIndices.map((_, i) => 
                    i === 0 ? 'rgba(46, 139, 87, 0.8)' : 'rgba(70, 130, 180, 0.8)'
                );
                
                // Wykres słupkowy wyników końcowych
                const finalData = [{
                    x: sortedLabels,
                    y: sortedValues,
                    type: 'bar',
                    marker: {
                        color: colors
                    },
                    text: sortedValues.map(v => v.toFixed(2) + '%'),
                    textposition: 'auto',
                    hoverinfo: 'text',
                    hovertext: sortedIndices.map(idx => 
                        `${AHP.optionNames[idx]}: ${(AHP.globalOptionWeights[idx] * 100).toFixed(2)}%`
                    )
                }];
                
                const finalLayout = {
                    title: 'Priorytet globalny opcji',
                    yaxis: {
                        title: 'Waga (%)',
                        range: [0, Math.max(...sortedValues) * 1.1]
                    },
                    margin: {
                        l: 50,
                        r: 30,
                        b: 80,
                        t: 50,
                        pad: 4
                    },
                    showlegend: false
                };
                
                const config = {
                    displayModeBar: false,  // Ukryj pasek narzędzi
                    responsive: true
                };
                
                // Wykres słupkowy z priorytetami kryteriów
                const criteriaChart = document.createElement('div');
                criteriaChart.style.width = '100%';
                criteriaChart.style.height = '300px';
                criteriaChart.style.marginBottom = '30px';
                container.appendChild(criteriaChart);
                
                const criteriaData = [{
                    x: AHP.criteriaNames,
                    y: AHP.criteriaPriorities.map(p => p * 100),
                    type: 'bar',
                    marker: {
                        color: 'rgba(139, 69, 19, 0.7)'
                    },
                    text: AHP.criteriaPriorities.map(p => (p * 100).toFixed(2) + '%'),
                    textposition: 'auto',
                    hoverinfo: 'text',
                    hovertext: AHP.criteriaNames.map((name, i) => 
                        `${name}: ${(AHP.criteriaPriorities[i] * 100).toFixed(2)}%`
                    )
                }];
                
                const criteriaLayout = {
                    title: 'Ważność kryteriów',
                    yaxis: {
                        title: 'Waga (%)',
                        range: [0, Math.max(...AHP.criteriaPriorities) * 110]
                    },
                    margin: {
                        l: 50,
                        r: 30,
                        b: 80,
                        t: 50,
                        pad: 4
                    },
                    showlegend: false
                };
                
                Plotly.newPlot(criteriaChart, criteriaData, criteriaLayout, config);
                
                // Wykres słupkowy z wynikami końcowymi
                const finalChartContainer = document.createElement('div');
                finalChartContainer.className = 'chart-with-legend';
                container.appendChild(finalChartContainer);
                
                const finalChart = document.createElement('div');
                finalChart.style.width = '100%';
                finalChart.style.height = '300px';
                finalChartContainer.appendChild(finalChart);
                
                Plotly.newPlot(finalChart, finalData, finalLayout, config);
                
                // Dodaj legendę pod wykresem
                const legend = document.createElement('div');
                legend.className = 'chart-legend';
                legend.innerHTML = `
                    <p><strong>Legenda:</strong></p>
                    <ul>
                        <li><span class="legend-item best">■</span> Najlepsza opcja</li>
                        <li><span class="legend-item other">■</span> Pozostałe opcje</li>
                    </ul>
                `;
                finalChartContainer.appendChild(legend);
                
                // Dodaj tabelkę z rozbiciem na kryteria
                const breakdownContainer = document.createElement('div');
                breakdownContainer.className = 'results-table-container';
                breakdownContainer.style.marginTop = '30px';
                
                const breakdownTitle = document.createElement('h3');
                breakdownTitle.textContent = 'Rozbicie wyników według kryteriów';
                breakdownContainer.appendChild(breakdownTitle);
                
                const breakdownTable = document.createElement('table');
                breakdownTable.className = 'comparison-matrix results-breakdown';
                
                // Nagłówki kolumn
                const bthead = document.createElement('thead');
                const bheaderRow = document.createElement('tr');
                
                const bth1 = document.createElement('th');
                bth1.textContent = 'Opcja';
                bheaderRow.appendChild(bth1);
                
                // Dodaj nagłówki dla każdego kryterium
                for (let c = 0; c < AHP.numCriteria; c++) {
                    const th = document.createElement('th');
                    th.textContent = AHP.criteriaNames[c];
                    bheaderRow.appendChild(th);
                }
                
                const bth2 = document.createElement('th');
                bth2.textContent = 'Wynik';
                bheaderRow.appendChild(bth2);
                
                bthead.appendChild(bheaderRow);
                breakdownTable.appendChild(bthead);
                
                // Ciało tabeli
                const btbody = document.createElement('tbody');
                
                for (let i = 0; i < AHP.numOptions; i++) {
                    const idx = sortedIndices[i];
                    const row = document.createElement('tr');
                    
                    const td1 = document.createElement('td');
                    td1.textContent = AHP.optionNames[idx];
                    row.appendChild(td1);
                    
                    // Dodaj komórki dla każdego kryterium z wartością lokalną
                    for (let c = 0; c < AHP.numCriteria; c++) {
                        const td = document.createElement('td');
                        const localValue = AHP.localOptionWeights[c][idx];
                        const weightedValue = localValue * AHP.criteriaPriorities[c];
                        
                        td.textContent = `${(localValue * 100).toFixed(1)}%`;
                        
                        // Dodaj kolorowanie tła zależne od wartości
                        const intensity = Math.min(localValue * 2, 1);  // Ograniczenie intensywności do 1
                        td.style.backgroundColor = `rgba(70, 130, 180, ${intensity * 0.3})`;
                        
                        row.appendChild(td);
                    }
                    
                    const td2 = document.createElement('td');
                    td2.textContent = `${(AHP.globalOptionWeights[idx] * 100).toFixed(2)}%`;
                    td2.className = 'final-score';
                    
                    row.appendChild(td2);
                    
                    if (i === 0) {
                        row.className = 'best-option';
                    }
                    
                    btbody.appendChild(row);
                }
                
                breakdownTable.appendChild(btbody);
                breakdownContainer.appendChild(breakdownTable);
                
                // Dodaj informację o intensywności koloru
                const colorInfo = document.createElement('p');
                colorInfo.className = 'color-info';
                colorInfo.textContent = 'Intensywność niebieskiego koloru odzwierciedla wynik opcji w danym kryterium.';
                breakdownContainer.appendChild(colorInfo);
                
                container.appendChild(breakdownContainer);
            }
        };

        const CuttingStock = {
            currentLogLength: 2.0,
            orders: [],

            init: () => {
                console.log("Initializing Cutting Stock module");
                try {
                    CuttingStock.orders = [];
                    const logLengthInput = document.getElementById('logLength');
                    if (!logLengthInput) {
                        console.error("Nie znaleziono elementu 'logLength'");
                        return;
                    }
                    
                    logLengthInput.value = CuttingStock.currentLogLength;
                    
                    const ordersList = document.getElementById('ordersList');
                    if (!ordersList) {
                        console.error("Nie znaleziono elementu 'ordersList'");
                        return;
                    }
                    
                    // Sprawdź, czy istnieje pole limitu kłód, jeśli nie - dodaj je
                    let numLogsField = document.getElementById('numLogs');
                    if (!numLogsField) {
                        const logLimitRow = document.createElement('div');
                        logLimitRow.className = 'input-row';
                        
                        const logLimitLabel = document.createElement('label');
                        logLimitLabel.textContent = 'Limit kłód (opcjonalnie):';
                        
                        numLogsField = document.createElement('input');
                        numLogsField.type = 'number';
                        numLogsField.id = 'numLogs';
                        numLogsField.min = '1';
                        
                        logLimitRow.appendChild(logLimitLabel);
                        logLimitRow.appendChild(numLogsField);
                        
                        // Dodaj przed sekcją zamówień
                        if (ordersList.parentNode) {
                            ordersList.parentNode.insertBefore(logLimitRow, ordersList);
                        }
                    }
                    
                    Utils.clearElement('ordersList');
                    CuttingStock.addOrderRow();
                    Utils.hideElement('cuttingStockResults');
                    Utils.hideElement('cuttingStockVisualization');
                    
                    console.log("Cutting Stock module initialized successfully");
                } catch (error) {
                    console.error("Error during CuttingStock initialization:", error);
                }
            },
            
            addOrderRow: () => {
                try {
                    const ordersList = document.getElementById('ordersList');
                    if (!ordersList) {
                        console.error("Nie znaleziono elementu 'ordersList'");
                        return;
                    }
                    
                    const orderIndex = CuttingStock.orders.length;
                    
                    const orderRow = document.createElement('div');
                    orderRow.className = 'input-row order-row';
                    orderRow.id = `order-row-${orderIndex}`;
                    
                    // Długość sztuki
                    const lengthLabel = document.createElement('label');
                    lengthLabel.textContent = 'Długość (m):';
                    
                    const lengthInput = document.createElement('input');
                    lengthInput.type = 'number';
                    lengthInput.id = `order-length-${orderIndex}`;
                    lengthInput.className = 'length-input';
                    lengthInput.step = '0.01';
                    lengthInput.min = '0.01';
                    lengthInput.max = `${CuttingStock.currentLogLength}`;
                    lengthInput.value = '0.5';
                    
                    // Liczba sztuk
                    const quantityLabel = document.createElement('label');
                    quantityLabel.textContent = 'Liczba sztuk:';
                    
                    const quantityInput = document.createElement('input');
                    quantityInput.type = 'number';
                    quantityInput.id = `order-quantity-${orderIndex}`;
                    quantityInput.className = 'quantity-input';
                    quantityInput.min = '1';
                    quantityInput.value = '1';
                    
                    // Przycisk usunięcia
                    const removeButton = document.createElement('button');
                    removeButton.textContent = 'Usuń';
                    removeButton.onclick = () => CuttingStock.removeOrderRow(orderIndex);
                    
                    orderRow.appendChild(lengthLabel);
                    orderRow.appendChild(lengthInput);
                    orderRow.appendChild(quantityLabel);
                    orderRow.appendChild(quantityInput);
                    orderRow.appendChild(removeButton);
                    
                    ordersList.appendChild(orderRow);
                    
                    // Dodaj nowe zamówienie do listy
                    CuttingStock.orders.push({ length: 0.5, quantity: 1 });
                    
                    console.log(`Dodano nowy wiersz zamówienia (index: ${orderIndex})`);
                    console.log("Aktualna lista zamówień:", CuttingStock.orders);
                } catch (error) {
                    console.error("Błąd podczas dodawania wiersza zamówienia:", error);
                }
            },
            
            removeOrderRow: (index) => {
                const element = document.getElementById(`order-row-${index}`);
                if (element) {
                    element.remove();
                }
                
                // Aktualizuj indeksy pozostałych zamówień
                for (let i = index + 1; i < CuttingStock.orders.length; i++) {
                    const row = document.getElementById(`order-row-${i}`);
                    if (row) {
                        row.id = `order-row-${i-1}`;
                        
                        const lengthInput = document.getElementById(`order-length-${i}`);
                        if (lengthInput) lengthInput.id = `order-length-${i-1}`;
                        
                        const quantityInput = document.getElementById(`order-quantity-${i}`);
                        if (quantityInput) quantityInput.id = `order-quantity-${i-1}`;
                        
                        const removeButton = row.querySelector('button');
                        if (removeButton) removeButton.onclick = () => CuttingStock.removeOrderRow(i-1);
                    }
                }
                
                // Usuń zamówienie z listy
                CuttingStock.orders.splice(index, 1);
            },
            
            calculate: () => {
                console.log("Uruchamianie funkcji calculate dla modułu CuttingStock");
                try {
                    // Pokaż wskaźnik ładowania
                    const loadingIndicator = document.getElementById('cuttingStockLoadingIndicator');
                    if (loadingIndicator) {
                        loadingIndicator.style.display = 'block';
                    }
                    
                    // Ukryj poprzednie wyniki
                    Utils.hideElement('cuttingStockResults');
                    Utils.hideElement('cuttingStockVisualization');
                    
                    // Aktualizuj długość kłody
                    const logLengthInput = document.getElementById('logLength');
                    if (!logLengthInput) {
                        throw new Error("Nie znaleziono elementu 'logLength'");
                    }
                    
                    CuttingStock.currentLogLength = parseFloat(logLengthInput.value);
                    if (isNaN(CuttingStock.currentLogLength) || CuttingStock.currentLogLength <= 0) {
                        throw new Error("Nieprawidłowa długość kłody. Wprowadź liczbę większą od zera.");
                    }
                    
                    console.log(`Długość kłody: ${CuttingStock.currentLogLength}`);
                    
                    // Zbierz zamówienia
                    CuttingStock.orders = [];
                    
                    const orderRows = document.querySelectorAll('#ordersList .order-row');
                    if (orderRows.length === 0) {
                        throw new Error("Nie dodano żadnych zamówień. Dodaj co najmniej jedno zamówienie.");
                    }
                    
                    orderRows.forEach(row => {
                        const lengthInput = row.querySelector('.length-input');
                        const quantityInput = row.querySelector('.quantity-input');
                        
                        if (!lengthInput || !quantityInput) {
                            console.error("Nieprawidłowy wiersz zamówienia", row);
                            return;
                        }
                        
                        const length = parseFloat(lengthInput.value);
                        const quantity = parseInt(quantityInput.value);
                        
                        if (isNaN(length) || length <= 0) {
                            throw new Error("Nieprawidłowa długość w zamówieniu. Wszystkie długości muszą być liczbami większymi od zera.");
                        }
                        
                        if (isNaN(quantity) || quantity <= 0) {
                            throw new Error("Nieprawidłowa ilość w zamówieniu. Wszystkie ilości muszą być liczbami całkowitymi większymi od zera.");
                        }
                        
                        if (length > CuttingStock.currentLogLength) {
                            throw new Error(`Długość zamówienia (${length} m) przekracza długość kłody (${CuttingStock.currentLogLength} m).`);
                        }
                        
                        CuttingStock.orders.push({
                            length: length,
                            quantity: quantity
                        });
                    });
                    
                    if (CuttingStock.orders.length === 0) {
                        throw new Error("Nie dodano żadnych prawidłowych zamówień. Sprawdź wprowadzone dane.");
                    }
                    
                    console.log("Zebrane zamówienia:", CuttingStock.orders);
                    
                    // Limit kłód (opcjonalnie)
                    let maxLogs = null;
                    const numLogsInput = document.getElementById('numLogs');
                    if (numLogsInput && numLogsInput.value.trim() !== '') {
                        maxLogs = parseInt(numLogsInput.value);
                        if (isNaN(maxLogs) || maxLogs <= 0) {
                            throw new Error("Nieprawidłowy limit kłód. Wprowadź liczbę całkowitą większą od zera lub pozostaw puste.");
                        }
                    }
                    
                    // Sprawdź opcję "Dokładnie X"
                    const exactCuts = document.getElementById('exactCuts') ? document.getElementById('exactCuts').checked : false;
                    
                    // Rozwiąż problem
                    setTimeout(() => {
                        try {
                            // Sprawdź dostępność biblioteki solver
                            if (typeof solver !== 'object' || typeof solver.Solve !== 'function') {
                                throw new Error("Biblioteka solver.js nie jest dostępna. Sprawdź połączenie internetowe i odśwież stronę.");
                            }
                            
                            const result = CuttingStock.solveCuttingStock();
                            
                            // Ukryj wskaźnik ładowania
                            if (loadingIndicator) {
                                loadingIndicator.style.display = 'none';
                            }
                            
                            // Wyświetl wyniki
                            CuttingStock.displayResults(result);
                        } catch (error) {
                            // Ukryj wskaźnik ładowania
                            if (loadingIndicator) {
                                loadingIndicator.style.display = 'none';
                            }
                            
                            console.error("Błąd podczas rozwiązywania problemu:", error);
                            Utils.displayError(error.message || "Wystąpił nieznany błąd podczas obliczeń.");
                        }
                    }, 100); // Małe opóźnienie dla wyrenderowania UI
                } catch (error) {
                    // Ukryj wskaźnik ładowania
                    const loadingIndicator = document.getElementById('cuttingStockLoadingIndicator');
                    if (loadingIndicator) {
                        loadingIndicator.style.display = 'none';
                    }
                    
                    console.error("Błąd podczas przygotowania danych:", error);
                    Utils.displayError(error.message || "Wystąpił nieznany błąd podczas przygotowania danych.");
                }
            },
            
            solveCuttingStock: () => {
                try {
                    // Sprawdź dostępność biblioteki solver
                    console.log("Sprawdzam dostępność biblioteki solver:", typeof solver);
                    if (typeof solver !== 'object' || typeof solver.Solve !== 'function') {
                        console.error("Biblioteka solver jest niedostępna lub nie zawiera funkcji Solve:", solver);
                        throw new Error("Biblioteka solver.js nie jest poprawnie załadowana. Odśwież stronę, aby spróbować ponownie.");
                    }
                    
                    // Przygotuj i rozwiąż problem cięcia
                    const exactCuts = document.getElementById('exactCuts').checked;
                    const stockLength = CuttingStock.currentLogLength;
                    
                    // Generowanie możliwych wzorów cięcia
                    const patterns = CuttingStock.generateCuttingPatterns();
                    
                    if (patterns.length === 0) {
                        throw new Error("Nie znaleziono żadnych możliwych wzorów cięcia dla podanych długości.");
                    }
                    
                    console.log("Wygenerowano wzory cięcia:", patterns);
                    
                    // Wybierz najlepsze wzory
                    // Jeśli exactCuts=false, to wybieramy wzory z maksymalną efektywnością
                    // Jeśli exactCuts=true, to używamy wszystkich wzorów
                    const bestPatterns = exactCuts ? patterns : patterns.slice(0, 100);
                    
                    // Przygotowanie modelu programowania liniowego
                    // W przypadku gdy nie wymagamy dokładnych liczb, optymalizujemy kombinację
                    // minimalizacji liczby kłód oraz maksymalizacji wykorzystania materiału
                    let model;
                    
                    if (exactCuts) {
                        // Dokładna liczba sztuk - minimalizujemy tylko liczbę kłód
                        model = {
                            optimize: 'numLogs',
                            opType: 'min',
                            constraints: {},
                            variables: {}
                        };
                        
                        // Dla każdego rozmiaru, dodaj ograniczenie równości
                        for (let i = 0; i < CuttingStock.orders.length; i++) {
                            const order = CuttingStock.orders[i];
                            model.constraints[`demand${i}`] = { equal: order.quantity };
                        }
                        
                        // Dodaj zmienne dla każdego wzoru cięcia
                        for (let i = 0; i < bestPatterns.length; i++) {
                            const pattern = bestPatterns[i];
                            const variable = {};
                            
                            // Ile każdego rozmiaru jest w tym wzorze
                            for (let j = 0; j < CuttingStock.orders.length; j++) {
                                variable[`demand${j}`] = pattern.counts[j];
                            }
                            
                            // Koszt użycia tego wzoru (1 kłoda)
                            variable.numLogs = 1;
                            
                            model.variables[`pattern${i}`] = variable;
                        }
                    } else {
                        // Minimalna liczba sztuk - optymalizujemy zarówno liczbę kłód jak i odpad
                        model = {
                            optimize: 'score',
                            opType: 'min',
                            constraints: {},
                            variables: {}
                        };
                        
                        // Dla każdego rozmiaru, dodaj ograniczenie minimum
                        for (let i = 0; i < CuttingStock.orders.length; i++) {
                            const order = CuttingStock.orders[i];
                            model.constraints[`demand${i}`] = { min: order.quantity };
                        }
                        
                        // Dodaj zmienne dla każdego wzoru cięcia
                        for (let i = 0; i < bestPatterns.length; i++) {
                            const pattern = bestPatterns[i];
                            const variable = {};
                            
                            // Ile każdego rozmiaru jest w tym wzorze
                            for (let j = 0; j < CuttingStock.orders.length; j++) {
                                variable[`demand${j}`] = pattern.counts[j];
                            }
                            
                            // Koszt składa się z kosztu użycia kłody plus koszt odpadu
                            variable.numLogs = 1;
                            
                            // Wartość funkcji celu to kombinacja liczby kłód i odpadu
                            // Mnożymy odpad przez współczynnik, aby miał znaczenie, ale nie dominował
                            // nad liczbą kłód (główny cel to minimalizacja liczby kłód)
                            const wasteWeight = 0.01; // Waga odpadu w funkcji celu
                            variable.score = 1 + wasteWeight * pattern.waste;
                            
                            model.variables[`pattern${i}`] = variable;
                        }
                    }
                    
                    console.log("Model optymalizacji:", model);
                    
                    // Rozwiąż problem programowania liniowego
                    console.log("Wywołuję solver.Solve z modelem...");
                    const solution = solver.Solve(model);
                    console.log("Rozwiązanie:", solution);
                    
                    if (!solution.feasible) {
                        throw new Error("Nie znaleziono wykonalnego rozwiązania dla podanych parametrów.");
                    }
                    
                    // Przygotuj wyniki
                    const result = {
                        solution: solution,
                        patterns: bestPatterns,
                        totalLogs: 0,
                        waste: 0,
                        usedPatterns: []
                    };
                    
                    // Oblicz odpady i użyte wzory
                    for (const key in solution) {
                        if (key.startsWith('pattern')) {
                            const patternIndex = parseInt(key.replace('pattern', ''));
                            const count = Math.round(solution[key]); // Zaokrąglamy do liczby całkowitej
                            
                            if (count > 0) {
                                const pattern = bestPatterns[patternIndex];
                                
                                // Oblicz odpad
                                const used = pattern.sizes.reduce((acc, size) => acc + size, 0);
                                const waste = (stockLength - used) * count;
                                
                                result.waste += waste;
                                result.totalLogs += count;
                                
                                result.usedPatterns.push({
                                    pattern: pattern,
                                    count: count
                                });
                            }
                        }
                    }
                    
                    // Jeśli coś poszło nie tak z liczeniem kłód, użyj wartości z rozwiązania
                    if (result.totalLogs === 0 && solution.numLogs) {
                        result.totalLogs = Math.round(solution.numLogs);
                    }
                    
                    // Formatowanie wyniku
                    result.waste = Math.round(result.waste * 100) / 100;
                    
                    return result;
                } catch (error) {
                    console.error("Błąd w rozwiązywaniu problemu rozkroju:", error);
                    throw error;
                }
            },
            
            generateCuttingPatterns: () => {
                console.log("Generowanie wzorów cięcia...");
                try {
                    const stockLength = CuttingStock.currentLogLength;
                    console.log(`Długość kłody: ${stockLength}m`);
                    
                    const sizes = CuttingStock.orders.map(order => order.length);
                    console.log(`Dostępne rozmiary: ${sizes.join(', ')}m`);
                    
                    if (sizes.length === 0) {
                        console.error("Brak rozmiarów do wygenerowania wzorów");
                        return [];
                    }
                    
                    const patterns = [];
                    
                    // Funkcja pomocnicza do generowania wszystkich kombinacji cięcia
                    const generatePatterns = (remaining, currentPattern, currentCounts, index) => {
                        // Jeśli doszliśmy do końca listy rozmiarów, zapisujemy wzór
                        if (index >= sizes.length) {
                            if (currentPattern.length > 0) {
                                // Oblicz efektywność wzoru (wykorzystanie materiału)
                                const totalUsed = currentPattern.reduce((acc, size) => acc + size, 0);
                                const waste = stockLength - totalUsed;
                                const efficiency = totalUsed / stockLength;
                                
                                patterns.push({
                                    sizes: [...currentPattern],
                                    counts: [...currentCounts],
                                    waste: waste,
                                    efficiency: efficiency
                                });
                            }
                            return;
                        }
                        
                        const currentSize = sizes[index];
                        const maxItems = Math.floor(remaining / currentSize);
                        
                        // Próbujemy dodać 0 do maxItems sztuk bieżącego rozmiaru
                        for (let i = 0; i <= maxItems; i++) {
                            const newPattern = [...currentPattern];
                            const newCounts = [...currentCounts];
                            
                            // Dodaj i sztuk bieżącego rozmiaru
                            for (let j = 0; j < i; j++) {
                                newPattern.push(currentSize);
                            }
                            
                            newCounts[index] = i;
                            
                            // Przejdź do następnego rozmiaru
                            generatePatterns(remaining - i * currentSize, newPattern, newCounts, index + 1);
                            
                            // Optymalizacja: jeśli wykorzystaliśmy maksymalnie dostępną przestrzeń,
                            // nie ma potrzeby sprawdzać więcej kombinacji z tym rozmiarem
                            if (remaining - i * currentSize < Math.min(...sizes)) {
                                break;
                            }
                        }
                    };
                    
                    // Inicjuj generowanie wzorów
                    console.log("Rozpoczynam generowanie wzorów...");
                    generatePatterns(stockLength, [], Array(sizes.length).fill(0), 0);
                    console.log(`Wygenerowano ${patterns.length} wzorów przed usunięciem duplikatów`);
                    
                    // Usuń duplikaty i posortuj według najmniejszego odpadu
                    const uniquePatterns = [];
                    const patternMap = new Map();
                    
                    for (const pattern of patterns) {
                        const key = pattern.counts.join(',');
                        if (!patternMap.has(key)) {
                            patternMap.set(key, pattern);
                            uniquePatterns.push(pattern);
                        }
                    }
                    
                    // Sortujemy wzory według efektywności (od najwyższej do najniższej)
                    const sortedPatterns = uniquePatterns.sort((a, b) => {
                        // Najpierw sortujemy według odpadu (mniejszy odpad lepszy)
                        if (Math.abs(a.waste - b.waste) > 0.001) {
                            return a.waste - b.waste;
                        }
                        
                        // Jeśli odpad jest podobny, wybieramy wzór który wykorzystuje więcej kawałków
                        const sumA = a.counts.reduce((sum, count) => sum + count, 0);
                        const sumB = b.counts.reduce((sum, count) => sum + count, 0);
                        return sumB - sumA;
                    });
                    
                    console.log(`Ostatecznie wygenerowano ${sortedPatterns.length} unikalnych wzorów`);
                    
                    // Ogranicz liczbę wzorów do 1000, aby uniknąć problemów z wydajnością
                    if (sortedPatterns.length > 1000) {
                        console.warn(`Ograniczono liczbę wzorów do 1000 (z ${sortedPatterns.length})`);
                        return sortedPatterns.slice(0, 1000);
                    }
                    
                    return sortedPatterns;
                } catch (error) {
                    console.error("Błąd podczas generowania wzorów cięcia:", error);
                    return [];
                }
            },
            
            displayResults: (result) => {
                const resultsContainer = document.getElementById('cuttingStockResults');
                let output = "";
                
                // Nagłówek wyników
                output += `<div class="results-header">
                    <h3>Wyniki optymalizacji rozkroju</h3>
                </div>`;
                
                // Podsumowanie
                const wastePercentage = ((result.waste / (result.totalLogs * CuttingStock.currentLogLength)) * 100).toFixed(2);
                const efficiencyPercentage = (100 - parseFloat(wastePercentage)).toFixed(2);
                
                output += `<div class="results-summary">
                    <div class="summary-item">
                        <span class="summary-label">Liczba potrzebnych kłód:</span>
                        <span class="summary-value">${result.totalLogs}</span>
                    </div>
                    <div class="summary-item">
                        <span class="summary-label">Całkowita długość kłód:</span>
                        <span class="summary-value">${(result.totalLogs * CuttingStock.currentLogLength).toFixed(2)} m</span>
                    </div>
                    <div class="summary-item">
                        <span class="summary-label">Całkowity odpad:</span>
                        <span class="summary-value">${result.waste.toFixed(2)} m (${wastePercentage}%)</span>
                    </div>
                    <div class="summary-item">
                        <span class="summary-label">Efektywność wykorzystania:</span>
                        <span class="summary-value">${efficiencyPercentage}%</span>
                    </div>
                </div>`;
                
                // Szczegóły wykorzystanych wzorów cięcia
                output += `<div class="results-details">
                    <h4>Wykorzystane wzory cięcia:</h4>
                    <table class="patterns-table">
                        <thead>
                            <tr>
                                <th>Wzór</th>
                                <th>Liczba kłód</th>
                                <th>Efektywność</th>
                                <th>Odpad</th>
                                <th>Szczegóły</th>
                            </tr>
                        </thead>
                        <tbody>`;
                
                // Zebranie informacji o kawałkach dla każdego rozmiaru
                const totalPiecesByLength = {};
                for (let i = 0; i < CuttingStock.orders.length; i++) {
                    totalPiecesByLength[CuttingStock.orders[i].length] = 0;
                }
                
                // Iteracja po wzorach
                for (let i = 0; i < result.usedPatterns.length; i++) {
                    const patternInfo = result.usedPatterns[i];
                    const pattern = patternInfo.pattern;
                    const count = patternInfo.count;
                    
                    const used = pattern.sizes.reduce((acc, size) => acc + size, 0);
                    const efficiency = ((used / CuttingStock.currentLogLength) * 100).toFixed(2);
                    
                    // Aktualizacja sum całkowitych
                    for (let j = 0; j < CuttingStock.orders.length; j++) {
                        if (pattern.counts[j] > 0) {
                            totalPiecesByLength[CuttingStock.orders[j].length] += pattern.counts[j] * count;
                        }
                    }
                    
                    output += `<tr>
                        <td>Wzór ${i+1}</td>
                        <td>${count}</td>
                        <td>${efficiency}%</td>
                        <td>${pattern.waste.toFixed(2)} m</td>
                        <td>`;
                    
                    // Szczegóły wzoru
                    for (let j = 0; j < CuttingStock.orders.length; j++) {
                        if (pattern.counts[j] > 0) {
                            output += `${pattern.counts[j]} × ${CuttingStock.orders[j].length.toFixed(2)} m<br>`;
                        }
                    }
                    
                    output += `</td></tr>`;
                }
                
                output += `</tbody></table></div>`;
                
                // Podsumowanie kawałków
                output += `<div class="pieces-summary">
                    <h4>Podsumowanie kawałków:</h4>
                    <table class="pieces-table">
                        <thead>
                            <tr>
                                <th>Długość</th>
                                <th>Zamówiono</th>
                                <th>Otrzymano</th>
                                <th>Różnica</th>
                            </tr>
                        </thead>
                        <tbody>`;
                
                for (let i = 0; i < CuttingStock.orders.length; i++) {
                    const orderLength = CuttingStock.orders[i].length;
                    const orderQty = CuttingStock.orders[i].quantity;
                    const actualQty = totalPiecesByLength[orderLength];
                    const diff = actualQty - orderQty;
                    
                    output += `<tr>
                        <td>${orderLength.toFixed(2)} m</td>
                        <td>${orderQty}</td>
                        <td>${actualQty}</td>
                        <td>${diff >= 0 ? '+' + diff : diff}</td>
                    </tr>`;
                }
                
                output += `</tbody></table></div>`;
                
                // Dodajemy dodatkowe style dla nowego formatu wyników
                const styleElement = document.createElement('style');
                styleElement.textContent = `
                    .results-header {
                        margin-bottom: 15px;
                        padding-bottom: 10px;
                        border-bottom: 2px solid var(--medium-brown);
                    }
                    
                    .results-summary {
                        background-color: var(--cream);
                        padding: 15px;
                        border-radius: 8px;
                        margin-bottom: 20px;
                        display: grid;
                        grid-template-columns: 1fr 1fr;
                        gap: 10px;
                    }
                    
                    .summary-item {
                        display: flex;
                        justify-content: space-between;
                        padding: 5px 0;
                        border-bottom: 1px solid var(--light-brown);
                    }
                    
                    .summary-label {
                        font-weight: bold;
                    }
                    
                    .summary-value {
                        font-weight: bold;
                        color: var(--dark-brown);
                    }
                    
                    .results-details, .pieces-summary {
                        margin-top: 20px;
                    }
                    
                    .patterns-table, .pieces-table {
                        width: 100%;
                        border-collapse: collapse;
                        margin-top: 10px;
                    }
                    
                    .patterns-table th, .patterns-table td,
                    .pieces-table th, .pieces-table td {
                        border: 1px solid var(--light-brown);
                        padding: 8px;
                        text-align: center;
                    }
                    
                    .patterns-table th, .pieces-table th {
                        background-color: var(--medium-brown);
                        color: var(--white);
                    }
                    
                    .patterns-table tr:nth-child(even),
                    .pieces-table tr:nth-child(even) {
                        background-color: var(--cream);
                    }
                `;
                document.head.appendChild(styleElement);
                
                // Ustawienie zawartości
                resultsContainer.innerHTML = output;
                
                // Wizualizacja wyników
                CuttingStock.visualizeResults(result);
                
                // Pokazanie wyników
                Utils.showElement('cuttingStockResults');
            },
            
            visualizeResults: (result) => {
                if (!result || !result.usedPatterns || result.usedPatterns.length === 0) {
                    return;
                }
                
                // Przygotowanie kontenera
                const visualizationContainer = document.getElementById('cuttingStockVisualization');
                visualizationContainer.innerHTML = '<h4>Wizualizacja wzorów cięcia:</h4>';
                
                // Ustawienie kolorów dla każdego rozmiaru
                const orderColors = {};
                const colorScheme = [
                    '#3366CC', '#DC3912', '#FF9900', '#109618', '#990099', 
                    '#0099C6', '#DD4477', '#66AA00', '#B82E2E', '#316395'
                ];
                
                // Przypisanie kolorów do każdego rozmiaru
                for (let i = 0; i < CuttingStock.orders.length; i++) {
                    orderColors[CuttingStock.orders[i].length] = colorScheme[i % colorScheme.length];
                }
                
                // Tworzenie wizualizacji dla każdego wzoru
                for (let i = 0; i < result.usedPatterns.length; i++) {
                    const patternInfo = result.usedPatterns[i];
                    const pattern = patternInfo.pattern;
                    const count = patternInfo.count;
                    
                    // Tworzenie kontenera dla wzoru
                    const patternContainer = document.createElement('div');
                    patternContainer.className = 'pattern-container';
                    patternContainer.innerHTML = `
                        <div class="pattern-header">
                            <span class="pattern-title">Wzór ${i+1} (${count} ${count === 1 ? 'kłoda' : 'kłody'})</span>
                            <span class="pattern-efficiency">Efektywność: ${((1 - pattern.waste / CuttingStock.currentLogLength) * 100).toFixed(2)}%</span>
                        </div>
                    `;
                    
                    // Tworzenie wizualizacji kłody
                    const logViz = document.createElement('div');
                    logViz.className = 'log-visualization';
                    
                    // Tworzenie pełnej kłody (tło)
                    const fullLog = document.createElement('div');
                    fullLog.className = 'full-log';
                    fullLog.style.width = '100%';
                    fullLog.style.height = '40px';
                    fullLog.style.backgroundColor = '#8B4513'; // Kolor drewna
                    
                    logViz.appendChild(fullLog);
                    
                    // Przygotowanie segmentów cięcia
                    const segments = [];
                    let currentPosition = 0;
                    
                    // Dodawanie elementów dla każdego kawałka w wzorze
                    for (let j = 0; j < CuttingStock.orders.length; j++) {
                        const orderLength = CuttingStock.orders[j].length;
                        const count = pattern.counts[j];
                        
                        if (count > 0) {
                            // Dodaj segmenty do wizualizacji
                            for (let k = 0; k < count; k++) {
                                segments.push({
                                    position: currentPosition,
                                    length: orderLength,
                                    color: orderColors[orderLength],
                                    size: orderLength,
                                    count: count
                                });
                                currentPosition += orderLength;
                            }
                        }
                    }
                    
                    // Dodawanie odpadów (jeśli są)
                    if (pattern.waste > 0.001) { // Mały próg tolerancji dla błędów zmiennoprzecinkowych
                        segments.push({
                            position: currentPosition,
                            length: pattern.waste,
                            color: '#CCCCCC', // Szary kolor dla odpadu
                            isWaste: true
                        });
                    }
                    
                    // Sortowanie segmentów według pozycji
                    segments.sort((a, b) => a.position - b.position);
                    
                    // Rysowanie segmentów na kłodzie
                    const cutContainer = document.createElement('div');
                    cutContainer.className = 'cut-container';
                    cutContainer.style.position = 'relative';
                    cutContainer.style.height = '40px';
                    cutContainer.style.width = '100%';
                    cutContainer.style.marginTop = '-40px'; // Nakładanie na pełną kłodę
                    cutContainer.style.zIndex = '2';
                    
                    // Kontener dla etykiet pod segmentami
                    const labelsContainer = document.createElement('div');
                    labelsContainer.className = 'segment-labels-container';
                    labelsContainer.style.position = 'relative';
                    labelsContainer.style.height = '40px';
                    labelsContainer.style.width = '100%';
                    labelsContainer.style.marginTop = '5px';
                    
                    for (let segIndex = 0; segIndex < segments.length; segIndex++) {
                        const segment = segments[segIndex];
                        const percentWidth = (segment.length / CuttingStock.currentLogLength) * 100;
                        const percentPosition = (segment.position / CuttingStock.currentLogLength) * 100;
                        
                        // Rysuj segment
                        const segmentEl = document.createElement('div');
                        segmentEl.className = 'cut-segment';
                        segmentEl.style.position = 'absolute';
                        segmentEl.style.left = `${percentPosition}%`;
                        segmentEl.style.width = `${percentWidth}%`;
                        segmentEl.style.height = '100%';
                        segmentEl.style.backgroundColor = segment.color;
                        segmentEl.style.border = '1px solid #333';
                        
                        // Dodaj odstęp między segmentami
                        if (segIndex > 0) {
                            segmentEl.style.marginLeft = '2px';
                        }
                        
                        // Dodajemy etykietę z długością dla większych segmentów
                        if (percentWidth > 5) { // Tylko dla segmentów większych niż 5% długości kłody
                            const label = document.createElement('div');
                            label.className = 'segment-label';
                            label.textContent = segment.length.toFixed(2);
                            label.style.position = 'absolute';
                            label.style.width = '100%';
                            label.style.textAlign = 'center';
                            label.style.top = '50%';
                            label.style.transform = 'translateY(-50%)';
                            label.style.color = '#000';
                            label.style.fontWeight = 'bold';
                            label.style.textShadow = '0px 0px 2px white';
                            label.style.fontSize = '12px';
                            segmentEl.appendChild(label);
                        }
                        
                        cutContainer.appendChild(segmentEl);
                        
                        // Dodaj etykiety pod segmentami
                        if (!segment.isWaste) {
                            const sizeLabel = document.createElement('div');
                            sizeLabel.className = 'size-label';
                            sizeLabel.style.position = 'absolute';
                            sizeLabel.style.left = `${percentPosition + percentWidth/2}%`;
                            sizeLabel.style.transform = 'translateX(-50%)';
                            sizeLabel.style.top = '0';
                            sizeLabel.style.fontSize = '11px';
                            sizeLabel.style.fontWeight = 'bold';
                            sizeLabel.style.color = '#333';
                            sizeLabel.style.whiteSpace = 'nowrap';
                            sizeLabel.textContent = segment.size + ' m';
                            
                            const countLabel = document.createElement('div');
                            countLabel.className = 'count-label';
                            countLabel.style.position = 'absolute';
                            countLabel.style.left = `${percentPosition + percentWidth/2}%`;
                            countLabel.style.transform = 'translateX(-50%)';
                            countLabel.style.top = '15px';
                            countLabel.style.fontSize = '11px';
                            countLabel.style.color = '#333';
                            countLabel.style.whiteSpace = 'nowrap';
                            countLabel.textContent = `(${segment.count} szt.)`;
                            
                            labelsContainer.appendChild(sizeLabel);
                            labelsContainer.appendChild(countLabel);
                        } else {
                            // Etykieta dla odpadu
                            const wasteLabel = document.createElement('div');
                            wasteLabel.className = 'waste-label';
                            wasteLabel.style.position = 'absolute';
                            wasteLabel.style.left = `${percentPosition + percentWidth/2}%`;
                            wasteLabel.style.transform = 'translateX(-50%)';
                            wasteLabel.style.top = '0';
                            wasteLabel.style.fontSize = '11px';
                            wasteLabel.style.fontWeight = 'bold';
                            wasteLabel.style.color = '#333';
                            wasteLabel.style.whiteSpace = 'nowrap';
                            wasteLabel.textContent = 'Odpad:';
                            
                            const wasteSizeLabel = document.createElement('div');
                            wasteSizeLabel.className = 'waste-size-label';
                            wasteSizeLabel.style.position = 'absolute';
                            wasteSizeLabel.style.left = `${percentPosition + percentWidth/2}%`;
                            wasteSizeLabel.style.transform = 'translateX(-50%)';
                            wasteSizeLabel.style.top = '15px';
                            wasteSizeLabel.style.fontSize = '11px';
                            wasteSizeLabel.style.color = '#333';
                            wasteSizeLabel.style.whiteSpace = 'nowrap';
                            wasteSizeLabel.textContent = segment.length.toFixed(2) + ' m';
                            
                            labelsContainer.appendChild(wasteLabel);
                            labelsContainer.appendChild(wasteSizeLabel);
                        }
                    }
                    
                    // Dodanie podziałki
                    const rulerContainer = document.createElement('div');
                    rulerContainer.className = 'ruler-container';
                    rulerContainer.style.width = '100%';
                    rulerContainer.style.height = '20px';
                    rulerContainer.style.position = 'relative';
                    rulerContainer.style.marginTop = '50px'; // Więcej miejsca dla etykiet pod segmentami
                    rulerContainer.style.borderTop = '1px solid #333';
                    
                    // Znaczniki co 0.5m
                    const step = 0.5;
                    for (let mark = 0; mark <= CuttingStock.currentLogLength; mark += step) {
                        const marker = document.createElement('div');
                        marker.className = 'ruler-mark';
                        marker.style.position = 'absolute';
                        marker.style.left = `${(mark / CuttingStock.currentLogLength) * 100}%`;
                        marker.style.top = '0';
                        marker.style.height = mark % 1 === 0 ? '10px' : '5px'; // Wyższe znaczniki dla pełnych metrów
                        marker.style.width = '1px';
                        marker.style.backgroundColor = '#333';
                        
                        if (mark % 1 === 0) { // Etykiety tylko dla pełnych metrów
                            const label = document.createElement('div');
                            label.className = 'ruler-label';
                            label.textContent = mark.toFixed(0);
                            label.style.position = 'absolute';
                            label.style.left = '0';
                            label.style.top = '12px';
                            label.style.fontSize = '10px';
                            label.style.transform = 'translateX(-50%)';
                            marker.appendChild(label);
                        }
                        
                        rulerContainer.appendChild(marker);
                    }
                    
                    // Składanie wszystkiego razem
                    logViz.appendChild(cutContainer);
                    logViz.appendChild(labelsContainer);
                    logViz.appendChild(rulerContainer);
                    
                    patternContainer.appendChild(logViz);
                    
                    // Dodanie legendy - teraz usunięta, ponieważ mamy etykiety pod segmentami
                    
                    visualizationContainer.appendChild(patternContainer);
                }
                
                // Dodajemy dodatkowe style dla wizualizacji
                const styleElement = document.createElement('style');
                styleElement.textContent = `
                    #cuttingStockVisualization {
                        margin-top: 30px;
                        padding: 20px;
                        background-color: var(--cream);
                        border-radius: 8px;
                    }
                    
                    .pattern-container {
                        margin-bottom: 25px;
                        padding: 15px;
                        background-color: var(--white);
                        border-radius: 8px;
                        box-shadow: 0 2px 5px rgba(0,0,0,0.1);
                    }
                    
                    .pattern-header {
                        display: flex;
                        justify-content: space-between;
                        margin-bottom: 10px;
                        padding-bottom: 5px;
                        border-bottom: 1px solid var(--light-brown);
                    }
                    
                    .pattern-title {
                        font-weight: bold;
                        color: var(--dark-brown);
                    }
                    
                    .pattern-efficiency {
                        font-weight: bold;
                    }
                    
                    .log-visualization {
                        width: 100%;
                        margin-bottom: 15px;
                    }
                    
                    .full-log {
                        z-index: 1;
                        position: relative;
                    }
                    
                    .cut-segment {
                        box-shadow: 0 0 3px rgba(0,0,0,0.3);
                        margin-right: 2px;
                    }
                    
                    .ruler-container {
                        background-color: #f0f0f0;
                    }
                    
                    .segment-labels-container {
                        font-family: Arial, sans-serif;
                    }
                `;
                document.head.appendChild(styleElement);
                
                // Pokazanie wizualizacji
                Utils.showElement('cuttingStockVisualization');
            }
        };

        const ProductionOpt = {
            numVars: 2,
            constraints: [],

            init: () => {
                console.log("Initializing Production Optimization module");
                ProductionOpt.numVars = 2;
                ProductionOpt.constraints = [];
                document.getElementById('numVars').value = ProductionOpt.numVars;
                Utils.clearElement('constraints');
                ProductionOpt.updateObjectiveFunction();
                Utils.hideElement('productionOptResults');
            },
            
            updateObjectiveFunction: () => {
                const numVars = parseInt(document.getElementById('numVars').value);
                if (isNaN(numVars) || numVars < 1) {
                    Utils.displayResults('productionOptResults', 'Liczba zmiennych musi być większa od 0', true);
                    return;
                }
                
                ProductionOpt.numVars = numVars;
                
                // Aktualizuj funkcję celu
                const objFunctionContainer = document.getElementById('objectiveFunction');
                objFunctionContainer.innerHTML = '';
                
                const header = document.createElement('h3');
                header.textContent = 'Funkcja celu';
                objFunctionContainer.appendChild(header);
                
                const functionContainer = document.createElement('div');
                functionContainer.className = 'objective-function-container';
                
                for (let i = 0; i < numVars; i++) {
                    const coeffInput = document.createElement('input');
                    coeffInput.type = 'number';
                    coeffInput.id = `obj-coeff-${i}`;
                    coeffInput.placeholder = `Współczynnik x${i+1}`;
                    coeffInput.value = '1';
                    coeffInput.step = '0.01';
                    coeffInput.className = 'obj-coefficient';
                    
                    const varLabel = document.createElement('span');
                    varLabel.className = 'obj-variable';
                    varLabel.textContent = i < numVars - 1 ? `x${i+1} + ` : `x${i+1}`;
                    
                    functionContainer.appendChild(coeffInput);
                    functionContainer.appendChild(varLabel);
                }
                
                objFunctionContainer.appendChild(functionContainer);
                
                // Zaktualizuj istniejące ograniczenia, jeśli są
                ProductionOpt.updateConstraints();
            },
            
            updateConstraints: () => {
                const constraintsContainer = document.getElementById('constraints');
                constraintsContainer.innerHTML = '';
                
                if (ProductionOpt.constraints.length === 0) {
                    const header = document.createElement('h3');
                    header.textContent = 'Ograniczenia';
                    constraintsContainer.appendChild(header);
                    
                    // Dodaj pierwsze ograniczenie
                    ProductionOpt.addConstraint();
                 return;
             }

                const header = document.createElement('h3');
                header.textContent = 'Ograniczenia';
                constraintsContainer.appendChild(header);
                
                // Odtwórz istniejące ograniczenia z nowym układem
                for (let i = 0; i < ProductionOpt.constraints.length; i++) {
                    const constraint = ProductionOpt.constraints[i];
                    
                    const constraintDiv = document.createElement('div');
                    constraintDiv.className = 'constraint-container';
                    constraintDiv.id = `constraint-${i}`;
                    
                    // Kontener na wszystkie pola wejściowe ograniczenia
                    const inputsContainer = document.createElement('div');
                    inputsContainer.className = 'constraint-inputs';
                    
                    for (let j = 0; j < ProductionOpt.numVars; j++) {
                        const coeffInput = document.createElement('input');
                        coeffInput.type = 'number';
                        coeffInput.id = `constraint-${i}-coeff-${j}`;
                        coeffInput.placeholder = `Wsp. x${j+1}`;
                        coeffInput.value = constraint.coeffs[j] || '0';
                        coeffInput.step = '0.01';
                        coeffInput.className = 'constraint-input';
                        
                        const varLabel = document.createElement('span');
                        varLabel.textContent = j < ProductionOpt.numVars - 1 ? `x${j+1} + ` : `x${j+1}`;
                        
                        inputsContainer.appendChild(coeffInput);
                        inputsContainer.appendChild(varLabel);
                    }
                    
                    const typeSelect = document.createElement('select');
                    typeSelect.id = `constraint-${i}-type`;
                    typeSelect.className = 'constraint-operator';
                    
                    const options = [
                        { value: 'leq', label: '<=' },
                        { value: 'eq', label: '=' },
                        { value: 'geq', label: '>=' }
                    ];
                    
                    options.forEach(option => {
                        const optElem = document.createElement('option');
                        optElem.value = option.value;
                        optElem.textContent = option.label;
                        
                        if (option.value === constraint.type) {
                            optElem.selected = true;
                        }
                        
                        typeSelect.appendChild(optElem);
                    });
                    
                    const rhsInput = document.createElement('input');
                    rhsInput.type = 'number';
                    rhsInput.id = `constraint-${i}-rhs`;
                    rhsInput.placeholder = 'RHS';
                    rhsInput.value = constraint.rhs || '0';
                    rhsInput.step = '0.01';
                    rhsInput.className = 'constraint-rhs';
                    
                    const removeButton = document.createElement('button');
                    removeButton.textContent = 'Usuń';
                    removeButton.className = 'constraint-remove';
                    removeButton.onclick = () => ProductionOpt.removeConstraint(i);
                    
                    inputsContainer.appendChild(typeSelect);
                    inputsContainer.appendChild(rhsInput);
                    inputsContainer.appendChild(removeButton);
                    
                    constraintDiv.appendChild(inputsContainer);
                    
                    constraintsContainer.appendChild(constraintDiv);
                }
            },
            
            addConstraint: () => {
                // Dodaj nowe ograniczenie z zerowymi współczynnikami
                const newConstraint = {
                    coeffs: Array(ProductionOpt.numVars).fill(0),
                    type: 'leq',
                    rhs: 0
                };
                
                ProductionOpt.constraints.push(newConstraint);
                
                // Zamiast aktualizować cały kontener (co resetuje istniejące wartości),
                // dodajemy tylko nowe ograniczenie do kontenera
                const constraintsContainer = document.getElementById('constraints');
                
                // Sprawdź, czy nagłówek już istnieje
                if (constraintsContainer.querySelector('h3') === null) {
                    const header = document.createElement('h3');
                    header.textContent = 'Ograniczenia';
                    constraintsContainer.appendChild(header);
                }
                
                const constraintIndex = ProductionOpt.constraints.length - 1;
                
                // Tworzenie nowego wiersza ograniczenia z klasami dla responsywności
                const constraintDiv = document.createElement('div');
                constraintDiv.className = 'constraint-container';
                constraintDiv.id = `constraint-${constraintIndex}`;
                
                // Kontener na wszystkie pola wejściowe ograniczenia
                const inputsContainer = document.createElement('div');
                inputsContainer.className = 'constraint-inputs';
                
                // Dodanie pól dla współczynników
                for (let j = 0; j < ProductionOpt.numVars; j++) {
                    const coeffInput = document.createElement('input');
                    coeffInput.type = 'number';
                    coeffInput.id = `constraint-${constraintIndex}-coeff-${j}`;
                    coeffInput.placeholder = `Wsp. x${j+1}`;
                    coeffInput.value = '0';
                    coeffInput.step = '0.01';
                    coeffInput.className = 'constraint-input';
                    
                    const varLabel = document.createElement('span');
                    varLabel.textContent = j < ProductionOpt.numVars - 1 ? `x${j+1} + ` : `x${j+1}`;
                    
                    inputsContainer.appendChild(coeffInput);
                    inputsContainer.appendChild(varLabel);
                }
                
                // Dodanie pola wyboru typu ograniczenia
                const typeSelect = document.createElement('select');
                typeSelect.id = `constraint-${constraintIndex}-type`;
                typeSelect.className = 'constraint-operator';
                
                const options = [
                    { value: 'leq', label: '<=' },
                    { value: 'eq', label: '=' },
                    { value: 'geq', label: '>=' }
                ];
                
                options.forEach(option => {
                    const optElem = document.createElement('option');
                    optElem.value = option.value;
                    optElem.textContent = option.label;
                    
                    if (option.value === 'leq') {
                        optElem.selected = true;
                    }
                    
                    typeSelect.appendChild(optElem);
                });
                
                // Dodanie pola dla prawej strony ograniczenia
                const rhsInput = document.createElement('input');
                rhsInput.type = 'number';
                rhsInput.id = `constraint-${constraintIndex}-rhs`;
                rhsInput.placeholder = 'RHS';
                rhsInput.value = '0';
                rhsInput.step = '0.01';
                rhsInput.className = 'constraint-rhs';
                
                // Dodanie przycisku usuwania
                const removeButton = document.createElement('button');
                removeButton.textContent = 'Usuń';
                removeButton.className = 'constraint-remove';
                removeButton.onclick = () => ProductionOpt.removeConstraint(constraintIndex);
                
                // Składanie wszystkiego razem
                inputsContainer.appendChild(typeSelect);
                inputsContainer.appendChild(rhsInput);
                inputsContainer.appendChild(removeButton);
                
                constraintDiv.appendChild(inputsContainer);
                
                // Dodanie wiersza do kontenera
                constraintsContainer.appendChild(constraintDiv);
            },
            
            removeConstraint: (index) => {
                // Usuń ograniczenie o podanym indeksie
                ProductionOpt.constraints.splice(index, 1);
                ProductionOpt.updateConstraints();
            },
            
            calculate: () => {
                try {
                    // Przygotuj model optymalizacji
                    const model = ProductionOpt.prepareModel();
                    
                    // Rozwiąż problem
                    const solution = solver.Solve(model);
                    
                    // Wyświetl wyniki
                    ProductionOpt.displayResults(solution);
                } catch (error) {
                    console.error("Error in production optimization:", error);
                    Utils.displayResults('productionOptResults', `Błąd obliczenia: ${error.message}`, true);
                }
            },
            
            prepareModel: () => {
                // Odczytaj funkcję celu
                const objective = {};
                for (let i = 0; i < ProductionOpt.numVars; i++) {
                    const coeffInput = document.getElementById(`obj-coeff-${i}`);
                    const coeff = parseFloat(coeffInput.value);
                    
                    if (isNaN(coeff)) {
                        throw new Error(`Nieprawidłowy współczynnik dla zmiennej x${i+1} w funkcji celu.`);
                    }
                    
                    objective[`x${i+1}`] = coeff;
                }
                
                // Typ optymalizacji
                const optimizationType = document.getElementById('optimizationType').value;
                
                // Przygotuj model
                const model = {
                    optimize: 'result',
                    opType: optimizationType,
                    constraints: {},
                    variables: {}
                };
                
                // Dodaj zmienne decyzyjne
                for (let i = 0; i < ProductionOpt.numVars; i++) {
                    model.variables[`x${i+1}`] = {
                        result: objective[`x${i+1}`]
                    };
                    
                    // Domyślne ograniczenie nieujemności
                    model.constraints[`x${i+1}`] = { min: 0 };
                }
                
                // Dodaj ograniczenia
                for (let i = 0; i < ProductionOpt.constraints.length; i++) {
                    // Odczytaj wartości z formularza
                    const coeffs = [];
                    
                    for (let j = 0; j < ProductionOpt.numVars; j++) {
                        const coeffInput = document.getElementById(`constraint-${i}-coeff-${j}`);
                        const coeff = parseFloat(coeffInput.value);
                        
                        if (isNaN(coeff)) {
                            throw new Error(`Nieprawidłowy współczynnik dla zmiennej x${j+1} w ograniczeniu ${i+1}.`);
                        }
                        
                        coeffs.push(coeff);
                    }
                    
                    const typeSelect = document.getElementById(`constraint-${i}-type`);
                    const type = typeSelect.value;
                    
                    const rhsInput = document.getElementById(`constraint-${i}-rhs`);
                    const rhs = parseFloat(rhsInput.value);
                    
                    if (isNaN(rhs)) {
                        throw new Error(`Nieprawidłowa wartość RHS w ograniczeniu ${i+1}.`);
                    }
                    
                    // Zaktualizuj obiekt ograniczenia
                    ProductionOpt.constraints[i] = {
                        coeffs: coeffs,
                        type: type,
                        rhs: rhs
                    };
                    
                    // Dodaj ograniczenie do modelu
                    const constraint = {};
                    
                    for (let j = 0; j < ProductionOpt.numVars; j++) {
                        if (coeffs[j] !== 0) {
                            constraint[`x${j+1}`] = coeffs[j];
                        }
                    }
                    
                    if (Object.keys(constraint).length === 0) {
                        throw new Error(`Ograniczenie ${i+1} nie ma żadnych niezerowych współczynników.`);
                    }
                    
                    const constraintName = `constraint${i+1}`;
                    
                    if (type === 'leq') {
                        model.constraints[constraintName] = {
                            max: rhs
                        };
                    } else if (type === 'geq') {
                        model.constraints[constraintName] = {
                            min: rhs
                        };
                    } else if (type === 'eq') {
                        model.constraints[constraintName] = {
                            equal: rhs
                        };
                    }
                    
                    // Dodaj współczynniki do zmiennych
                    for (let j = 0; j < ProductionOpt.numVars; j++) {
                        if (coeffs[j] !== 0) {
                            if (!model.variables[`x${j+1}`][constraintName]) {
                                model.variables[`x${j+1}`][constraintName] = coeffs[j];
                            }
                        }
                    }
                }
                
                return model;
            },
            
            displayResults: (solution) => {
                const resultsContainer = document.getElementById('productionOptResults');
                let output = "Wyniki optymalizacji produkcji:\n\n";
                
                if (solution.feasible) {
                    output += `Status: Rozwiązanie znalezione\n`;
                    output += `Wartość funkcji celu: ${solution.result.toFixed(4)}\n\n`;
                    
                    output += "Wartości zmiennych:\n";
            for (let i = 0; i < ProductionOpt.numVars; i++) {
                        const varName = `x${i+1}`;
                        const value = solution[varName] || 0;
                        output += `${varName} = ${value.toFixed(4)}\n`;
                    }
                    
                    // Informacje o wykorzystaniu ograniczeń
                    output += "\nWykorzystanie ograniczeń:\n";
                    
                    for (let i = 0; i < ProductionOpt.constraints.length; i++) {
                        const constraint = ProductionOpt.constraints[i];
                        let lhs = 0;
                        
                        for (let j = 0; j < ProductionOpt.numVars; j++) {
                            const varName = `x${j+1}`;
                            const value = solution[varName] || 0;
                            lhs += constraint.coeffs[j] * value;
                        }
                        
                        const constraintName = `constraint${i+1}`;
                        let typeSymbol = '';
                        
                        if (constraint.type === 'leq') typeSymbol = '<=';
                        else if (constraint.type === 'geq') typeSymbol = '>=';
                        else typeSymbol = '=';
                        
                        output += `Ograniczenie ${i+1}: ${lhs.toFixed(4)} ${typeSymbol} ${constraint.rhs.toFixed(4)}`;
                        
                        // Sprawdź, czy ograniczenie jest aktywne (wiążące)
                        const precision = 1e-6;
                        if (Math.abs(lhs - constraint.rhs) < precision) {
                            output += " (aktywne)";
                        }
                        
                        output += "\n";
                    }
                } else {
                    output += "Status: Nie znaleziono rozwiązania\n";
                    output += "Problem może nie mieć rozwiązania lub być nieograniczony.\n";
                }
                
                Utils.displayResults('productionOptResults', output);
                
                // Wizualizacja wyników
                if (solution.feasible && ProductionOpt.numVars === 2) {
                    ProductionOpt.visualizeResults(solution);
                } else {
                    Utils.clearElement('productionOptVisualization');
                }
            },
            
            visualizeResults: (solution) => {
                // Wizualizacja wyników tylko dla 2 zmiennych
                if (ProductionOpt.numVars !== 2) {
                    return;
                }
                
                const container = document.getElementById('productionOptVisualization');
                container.innerHTML = '';
                
                // Przygotuj dane do wizualizacji
                const optX = solution.x1 || 0;
                const optY = solution.x2 || 0;
                
                // Utwórz odpowiedni zakres dla wykresu
                const maxX = Math.max(optX * 1.5, 10);
                const maxY = Math.max(optY * 1.5, 10);
                
                // Dane punktu optymalnego
                const optimalPoint = {
                    x: [optX],
                    y: [optY],
                    mode: 'markers',
                    type: 'scatter',
                    name: 'Rozwiązanie optymalne',
                    marker: {
                        size: 10,
                        color: 'rgba(255, 0, 0, 0.8)'
                    }
                };
                
                // Przygotuj linie ograniczeń
                const constraintLines = [];
                
                for (let i = 0; i < ProductionOpt.constraints.length; i++) {
                    const constraint = ProductionOpt.constraints[i];
                    
                    // Pomiń ograniczenia, które nie dotyczą obu zmiennych
                    if ((constraint.coeffs[0] === 0 && constraint.coeffs[1] === 0)) {
                        continue;
                    }
                    
                    // Oblicz punkty do narysowania linii ograniczenia
                    const x = [];
                    const y = [];
                    
                    // Punkt przecięcia z osią X (y = 0)
                    if (constraint.coeffs[0] !== 0) {
                        const xIntercept = constraint.rhs / constraint.coeffs[0];
                        x.push(xIntercept);
                        y.push(0);
                    } else {
                        x.push(0);
                        y.push(constraint.rhs / constraint.coeffs[1]);
                    }
                    
                    // Punkt przecięcia z osią Y (x = 0)
                    if (constraint.coeffs[1] !== 0) {
                        const yIntercept = constraint.rhs / constraint.coeffs[1];
                        x.push(0);
                        y.push(yIntercept);
             } else {
                        x.push(constraint.rhs / constraint.coeffs[0]);
                        y.push(0);
                    }
                    
                    // Dodaj linię na wykres
                    constraintLines.push({
                        x: x,
                        y: y,
                        mode: 'lines',
                        type: 'scatter',
                        name: `Ograniczenie ${i+1}`,
                        line: {
                            dash: 'solid',
                            width: 2
                        }
                    });
                }
                
                // Funkcja celu
                const objCoeffs = [];
                for (let i = 0; i < ProductionOpt.numVars; i++) {
                    const coeffInput = document.getElementById(`obj-coeff-${i}`);
                    objCoeffs.push(parseFloat(coeffInput.value));
                }
                
                // Narysuj linię funkcji celu przechodzącą przez punkt optymalny
                const objX = [];
                const objY = [];
                
                if (objCoeffs[1] !== 0) {
                    // Jeśli współczynnik przy y jest niezerowy, możemy wyrazić y jako funkcję x
                    objX.push(0);
                    objX.push(maxX);
                    
                    const optValue = objCoeffs[0] * optX + objCoeffs[1] * optY;
                    objY.push(optValue / objCoeffs[1]);
                    objY.push((optValue - objCoeffs[0] * maxX) / objCoeffs[1]);
                } else if (objCoeffs[0] !== 0) {
                    // Jeśli tylko x ma niezerowy współczynnik
                    const optValue = objCoeffs[0] * optX;
                    objX.push(optValue / objCoeffs[0]);
                    objX.push(optValue / objCoeffs[0]);
                    objY.push(0);
                    objY.push(maxY);
                }
                
                const objectiveLine = {
                    x: objX,
                    y: objY,
                    mode: 'lines',
                    type: 'scatter',
                    name: 'Funkcja celu',
                    line: {
                        dash: 'dash',
                        width: 2,
                        color: 'rgba(255, 0, 0, 0.8)'
                    }
                };
                
                // Przygotuj układ współrzędnych
                const layout = {
                    title: 'Wizualizacja optymalizacji',
                    xaxis: {
                        title: 'x1',
                        range: [0, maxX]
                    },
                    yaxis: {
                        title: 'x2',
                        range: [0, maxY]
                    },
                    showlegend: true
                };
                
                // Narysuj wykres
                const data = [optimalPoint, ...constraintLines];
                if (objX.length > 0) data.push(objectiveLine);
                
                Plotly.newPlot(container, data, layout);
            }
        };

        // Inicjalizacja aplikacji
        document.addEventListener('DOMContentLoaded', () => {
            // Ukryj wszystkie narzędzia na start
            document.querySelectorAll('.tool-content').forEach(tool => {
                tool.style.display = 'none';
            });

            // Dodaj obsługę zmiany liczby zmiennych w optymalizacji produkcji
            document.getElementById('numVars').addEventListener('change', () => {
                if (ProductionOpt.updateObjectiveFunction) {
                    ProductionOpt.updateObjectiveFunction();
                }
            });

            // Inicjalizacja pierwszego narzędzia (AHP)
            App.switchToTool('ahp');
        });
    </script>
</body>
</html>