# ROZDZIAŁ 4: IMPLEMENTACJA MODUŁÓW APLIKACJI

## 4.1 Moduł kalkulatora AHP

### 4.1.1 Algorytm metody AHP

W implementacji metody AHP zastosowano klasyczny algorytm zaproponowany przez Saaty'ego, składający się z następujących kroków:

1. **Definiowanie hierarchii problemu** - Implementacja umożliwia użytkownikowi zdefiniowanie do 6 kryteriów oraz do 6 opcji decyzyjnych. Liczba kryteriów jest konfigurowana przez użytkownika, co pozwala na elastyczne dostosowanie do różnych problemów decyzyjnych.

2. **Porównania parami kryteriów** - Zaimplementowano mechanizm wprowadzania porównań parami za pomocą interaktywnej macierzy, gdzie użytkownik wybiera wartości z przedziału 1/9 do 9, zgodnie ze skalą Saaty'ego. Implementacja automatycznie uzupełnia wartości w symetrycznych komórkach macierzy jako odwrotności.

```javascript
updateCriteriaComparisonValue: (i, j) => {
    const select = document.getElementById(`criteria-comp-${i}-${j}`);
    const value = parseFloat(select.value);
    const inverseCell = document.getElementById(`criteria-comp-value-${j}-${i}`);
    
    if (inverseCell) {
        inverseCell.textContent = (1 / value).toFixed(4);
    }
}
```

3. **Porównania parami opcji względem każdego kryterium** - Podobnie jak w przypadku kryteriów, dla każdego kryterium tworzona jest macierz porównań opcji, co pozwala na określenie lokalnych priorytetów opcji.

4. **Obliczanie priorytetów** - Implementacja wykorzystuje metodę średniej geometrycznej do obliczania priorytetów:

```javascript
calculatePriorities: (matrix) => {
    // Metoda średniej geometrycznej (Saaty)
    const size = matrix.length;
    const priorities = Array(size).fill(0);
    
    // Obliczenie średniej geometrycznej dla każdego wiersza
    for (let i = 0; i < size; i++) {
        let product = 1;
        for (let j = 0; j < size; j++) {
            product *= matrix[i][j];
        }
        priorities[i] = Math.pow(product, 1/size);
    }
    
    // Normalizacja
    const sum = priorities.reduce((acc, val) => acc + val, 0);
    for (let i = 0; i < size; i++) {
        priorities[i] /= sum;
    }
    
    return priorities;
}
```

5. **Obliczanie współczynnika spójności (CR)** - Implementacja zawiera funkcję obliczającą współczynnik spójności, który informuje o jakości porównań parami. Zgodnie z teorią AHP, wartość CR < 0.1 wskazuje na akceptowalną spójność ocen.

```javascript
calculateConsistencyRatio: (matrix, weights) => {
    const size = matrix.length;
    if (size <= 2) return 0; // Dla 1 lub 2 elementów CR zawsze 0
    
    // Obliczenie λ max
    const weightedSumVector = [];
    for (let i = 0; i < size; i++) {
        let sum = 0;
        for (let j = 0; j < size; j++) {
            sum += matrix[i][j] * weights[j];
        }
        weightedSumVector[i] = sum;
    }
    
    const consistencyVector = Array(size);
    
    for (let i = 0; i < size; i++) {
        consistencyVector[i] = weightedSumVector[i] / weights[i];
    }
    
    const lambdaMax = consistencyVector.reduce((acc, val) => acc + val, 0) / size;
    
    // Obliczenie CI (Consistency Index)
    const CI = (lambdaMax - size) / (size - 1);
    
    // Obliczenie CR (Consistency Ratio)
    return CI / AHP.RI[size];
}
```

6. **Obliczanie globalnych priorytetów opcji** - Ostateczny etap polega na obliczeniu globalnych priorytetów opcji poprzez sumowanie iloczynów lokalnych priorytetów opcji i odpowiadających im priorytetów kryteriów.

### 4.1.2 Wizualizacja wyników

Wizualizacja wyników AHP została zaimplementowana z wykorzystaniem biblioteki Plotly.js, oferując użytkownikowi różne perspektywy interpretacji wyników:

1. **Wykres słupkowy priorytetów globalnych** - Prezentuje końcowe priorytety opcji decyzyjnych, umożliwiając łatwą identyfikację najlepszej opcji.

2. **Wykres priorytetów kryteriów** - Pokazuje względną ważność poszczególnych kryteriów, co pozwala zrozumieć ich wpływ na ostateczną decyzję.

3. **Tabelaryczna prezentacja wyników** - Szczegółowa prezentacja wyników w postaci tabel, obejmująca zarówno priorytety globalne, jak i lokalne dla każdego kryterium, wraz z informacjami o współczynniku spójności.

Implementacja dynamicznie generuje wszystkie elementy wizualizacji w momencie zakończenia obliczeń:

```javascript
visualizeResults: () => {
    const container = document.getElementById('ahpVisualization');
    container.innerHTML = '';
    
    // Przygotuj dane do wykresu słupkowego
    const sortedIndices = Array.from(Array(AHP.numOptions).keys())
        .sort((a, b) => AHP.globalOptionWeights[b] - AHP.globalOptionWeights[a]);
    
    const sortedLabels = sortedIndices.map(idx => AHP.optionNames[idx]);
    const sortedValues = sortedIndices.map(idx => AHP.globalOptionWeights[idx] * 100);
    
    // Kolorowanie słupków - najlepszy zielony, pozostałe niebieskie
    const colors = sortedIndices.map((_, i) => 
        i === 0 ? 'rgba(46, 139, 87, 0.8)' : 'rgba(70, 130, 180, 0.8)'
    );
    
    // Wykres słupkowy wyników końcowych
    const finalData = [{
        x: sortedLabels,
        y: sortedValues,
        type: 'bar',
        marker: {
            color: colors
        },
        text: sortedValues.map(v => v.toFixed(2) + '%'),
        textposition: 'auto',
        hoverinfo: 'text',
        hovertext: sortedIndices.map(idx => 
            `${AHP.optionNames[idx]}: ${(AHP.globalOptionWeights[idx] * 100).toFixed(2)}%`
        )
    }];
    
    // [...] Pozostała część implementacji wizualizacji
}
```

## 4.2 Moduł problemu rozkroju

### 4.2.1 Algorytm generowania wzorów cięcia

Kluczowym elementem modułu rozkroju jest algorytm generowania wszystkich możliwych wzorów cięcia dla zadanej długości kłody. Implementacja wykorzystuje algorytm rekurencyjny, który efektywnie przeszukuje przestrzeń rozwiązań:

```javascript
generateCuttingPatterns: () => {
    console.log("Generowanie wzorów cięcia...");
    try {
        const stockLength = CuttingStock.currentLogLength;
        console.log(`Długość kłody: ${stockLength}m`);
        
        const sizes = CuttingStock.orders.map(order => order.length);
        console.log(`Dostępne rozmiary: ${sizes.join(', ')}m`);
        
        if (sizes.length === 0) {
            console.error("Brak rozmiarów do wygenerowania wzorów");
            return [];
        }
        
        const patterns = [];
        
        // Funkcja pomocnicza do generowania wszystkich kombinacji cięcia
        const generatePatterns = (remaining, currentPattern, currentCounts, index) => {
            // Jeśli doszliśmy do końca listy rozmiarów, zapisujemy wzór
            if (index >= sizes.length) {
                if (currentPattern.length > 0) {
                    // Oblicz efektywność wzoru (wykorzystanie materiału)
                    const totalUsed = currentPattern.reduce((acc, size) => acc + size, 0);
                    const waste = stockLength - totalUsed;
                    const efficiency = totalUsed / stockLength;
                    
                    patterns.push({
                        sizes: [...currentPattern],
                        counts: [...currentCounts],
                        waste: waste,
                        efficiency: efficiency
                    });
                }
                return;
            }
            
            const currentSize = sizes[index];
            const maxItems = Math.floor(remaining / currentSize);
            
            // Próbujemy dodać 0 do maxItems sztuk bieżącego rozmiaru
            for (let i = 0; i <= maxItems; i++) {
                const newPattern = [...currentPattern];
                const newCounts = [...currentCounts];
                
                // Dodaj i sztuk bieżącego rozmiaru
                for (let j = 0; j < i; j++) {
                    newPattern.push(currentSize);
                }
                
                newCounts[index] = i;
                
                // Przejdź do następnego rozmiaru
                generatePatterns(remaining - i * currentSize, newPattern, newCounts, index + 1);
                
                // Optymalizacja: jeśli wykorzystaliśmy maksymalnie dostępną przestrzeń,
                // nie ma potrzeby sprawdzać więcej kombinacji z tym rozmiarem
                if (remaining - i * currentSize < Math.min(...sizes)) {
                    break;
                }
            }
        };
        
        // Inicjuj generowanie wzorów
        console.log("Rozpoczynam generowanie wzorów...");
        generatePatterns(stockLength, [], Array(sizes.length).fill(0), 0);
        
        // [...] Postprocessing wzorów
    } catch (error) {
        console.error("Błąd podczas generowania wzorów cięcia:", error);
        return [];
    }
}
```

### 4.2.2 Modelowanie i rozwiązywanie problemu optymalizacyjnego

Po wygenerowaniu wzorów cięcia, problem jest formułowany jako zadanie programowania liniowego całkowitoliczbowego i rozwiązywany przy użyciu biblioteki solver.js:

```javascript
solveCuttingStock: () => {
    try {
        // [...] Przygotowanie danych
        
        // Przygotowanie i rozwiązanie problemu cięcia
        const exactCuts = document.getElementById('exactCuts').checked;
        const stockLength = CuttingStock.currentLogLength;
        
        // Generowanie możliwych wzorów cięcia
        const patterns = CuttingStock.generateCuttingPatterns();
        
        if (patterns.length === 0) {
            throw new Error("Nie znaleziono żadnych możliwych wzorów cięcia dla podanych długości.");
        }
        
        console.log("Wygenerowano wzory cięcia:", patterns);
        
        // Wybierz najlepsze wzory
        const bestPatterns = exactCuts ? patterns : patterns.slice(0, 100);
        
        // Przygotowanie modelu programowania liniowego
        let model;
        
        if (exactCuts) {
            // Dokładna liczba sztuk - minimalizujemy tylko liczbę kłód
            model = {
                optimize: 'numLogs',
                opType: 'min',
                constraints: {},
                variables: {}
            };
            
            // Dla każdego rozmiaru, dodaj ograniczenie równości
            for (let i = 0; i < CuttingStock.orders.length; i++) {
                const order = CuttingStock.orders[i];
                model.constraints[`demand${i}`] = { equal: order.quantity };
            }
            
            // [...] Dodawanie zmiennych do modelu
        } else {
            // Minimalna liczba sztuk - optymalizujemy zarówno liczbę kłód jak i odpad
            model = {
                optimize: 'score',
                opType: 'min',
                constraints: {},
                variables: {}
            };
            
            // [...] Definicja ograniczeń i zmiennych
        }
        
        console.log("Model optymalizacji:", model);
        
        // Rozwiąż problem programowania liniowego
        console.log("Wywołuję solver.Solve z modelem...");
        const solution = solver.Solve(model);
        
        // [...] Przygotowanie i zwrócenie wyników
    } catch (error) {
        console.error("Błąd w rozwiązywaniu problemu rozkroju:", error);
        throw error;
    }
}
```

### 4.2.3 Wizualizacja schematów cięcia

Implementacja obejmuje również moduł wizualizacji schematów cięcia, który prezentuje użytkownikowi graficzną reprezentację optymalnego rozwiązania:

```javascript
displayVisualization: (pattern) => {
    const container = document.getElementById('cuttingStockVisualization');
    container.innerHTML = '';
    container.style.display = 'block';
    
    const logLength = CuttingStock.currentLogLength;
    const totalWidth = 800;
    const barHeight = 50;
    const scale = totalWidth / logLength;
    
    // [...] Implementacja wizualizacji schematu cięcia
}
```

## 4.3 Moduł optymalizacji produkcji

### 4.3.1 Interfejs definiowania problemów optymalizacyjnych

Interfejs modułu optymalizacji produkcji umożliwia użytkownikowi zdefiniowanie:
- Liczby zmiennych decyzyjnych (produktów)
- Funkcji celu (maksymalizacja zysku lub minimalizacja kosztów)
- Współczynników funkcji celu
- Ograniczeń zasobów (liniowych zależności między zmiennymi)

Implementacja dynamicznie dostosowuje formularze do liczby zmiennych:

```javascript
updateObjectiveFunction: () => {
    const numVars = parseInt(document.getElementById('numVars').value);
    if (isNaN(numVars) || numVars < 1) {
        Utils.displayResults('productionOptResults', 'Liczba zmiennych musi być większa od 0', true);
        return;
    }
    
    ProductionOpt.numVars = numVars;
    
    // Aktualizuj funkcję celu
    const objFunctionContainer = document.getElementById('objectiveFunction');
    objFunctionContainer.innerHTML = '';
    
    // [...] Dynamiczne generowanie pól formularza
}
```

### 4.3.2 Implementacja algorytmu optymalizacji

Model optymalizacji produkcji jest formułowany jako zadanie programowania liniowego i rozwiązywany przy użyciu biblioteki solver.js:

```javascript
calculate: () => {
    try {
        // Przygotuj model optymalizacji
        const model = ProductionOpt.prepareModel();
        
        // Rozwiąż problem
        const solution = solver.Solve(model);
        
        // Wyświetl wyniki
        ProductionOpt.displayResults(solution);
    } catch (error) {
        console.error("Error in production optimization:", error);
        Utils.displayResults('productionOptResults', `Błąd obliczenia: ${error.message}`, true);
    }
},

prepareModel: () => {
    // Odczytaj funkcję celu
    const objective = {};
    for (let i = 0; i < ProductionOpt.numVars; i++) {
        const coeffInput = document.getElementById(`obj-coeff-${i}`);
        const coeff = parseFloat(coeffInput.value);
        
        if (isNaN(coeff)) {
            throw new Error(`Nieprawidłowy współczynnik dla zmiennej x${i+1} w funkcji celu.`);
        }
        
        objective[`x${i+1}`] = coeff;
    }
    
    // Typ optymalizacji
    const optimizationType = document.getElementById('optimizationType').value;
    
    // Przygotuj model
    const model = {
        optimize: 'result',
        opType: optimizationType,
        constraints: {},
        variables: {}
    };
    
    // [...] Definicja zmiennych i ograniczeń
    
    return model;
}
```

### 4.3.3 Wizualizacja wyników optymalizacji

Dla problemów z dwoma zmiennymi decyzyjnymi, implementacja obejmuje wizualizację graficzną obszaru rozwiązań dopuszczalnych oraz optymalnego punktu:

```javascript
visualizeResults: (solution) => {
    // Wizualizacja wyników tylko dla 2 zmiennych
    if (ProductionOpt.numVars !== 2) {
        return;
    }
    
    const container = document.getElementById('productionOptVisualization');
    container.innerHTML = '';
    
    // Przygotuj dane do wizualizacji
    const optX = solution.x1 || 0;
    const optY = solution.x2 || 0;
    
    // Utwórz odpowiedni zakres dla wykresu
    const maxX = Math.max(optX * 1.5, 10);
    const maxY = Math.max(optY * 1.5, 10);
    
    // Dane punktu optymalnego
    const optimalPoint = {
        x: [optX],
        y: [optY],
        mode: 'markers',
        type: 'scatter',
        name: 'Rozwiązanie optymalne',
        marker: {
            size: 10,
            color: 'rgba(255, 0, 0, 0.8)'
        }
    };
    
    // [...] Dodanie linii ograniczeń i funkcji celu
    
    // Przygotuj układ współrzędnych
    const layout = {
        title: 'Wizualizacja optymalizacji',
        xaxis: {
            title: 'x1',
            range: [0, maxX]
        },
        yaxis: {
            title: 'x2',
            range: [0, maxY]
        },
        showlegend: true
    };
    
    // Narysuj wykres
    const data = [optimalPoint, ...constraintLines];
    if (objX.length > 0) data.push(objectiveLine);
    
    Plotly.newPlot(container, data, layout);
}
```

## 4.4 Implementacja systemu pomocy i responsywności

### 4.4.1 System pomocy kontekstowej

Jednym z kluczowych elementów aplikacji jest system pomocy kontekstowej, który wspiera użytkownika w korzystaniu z poszczególnych modułów. Implementacja systemu pomocy obejmuje:

1. **Przyciski pomocy z zaawansowanymi animacjami** - Każdy moduł wyposażony jest w przycisk pomocy, który przyciąga uwagę użytkownika dzięki sekwencji animacji:

```javascript
// Funkcja zarządzająca animacjami przycisku pomocy
function manageHelpButtonAnimation(button) {
    if (!button || helpButtonClicked) return;
    
    // Dodaj animację wjazdu od prawej strony
    addSlideInEffect(button);
    
    // Dodaj pulsowanie
    addPulseEffect(button);
    
    // Zatrzymaj pulsowanie po 3 sekundach
    setTimeout(() => {
        removePulseEffect(button);
    }, 3000);
    
    // Ustawienie interwału dla powtarzającego się pulsowania co minutę
    const pulseInterval = setInterval(() => {
        if (helpButtonClicked) {
            clearInterval(pulseInterval);
            return;
        }
        
        // Dodaj pulsowanie
        addPulseEffect(button);
        
        // Zatrzymaj pulsowanie po 3 sekundach
        setTimeout(() => {
            removePulseEffect(button);
        }, 3000);
    }, 60000); // Co minutę
}
```

Animacje przycisku pomocy zostały starannie zaprojektowane, aby zwrócić uwagę użytkownika bez rozpraszania go podczas pracy:

- **Animacja wjazdu** - Przycisk pomocy wjeżdża od prawej krawędzi ekranu przy pierwszym uruchomieniu strony, co natychmiast przyciąga uwagę użytkownika.
- **Pulsowanie z kolorowym podświetleniem** - Po wjeździe przycisk pulsuje przez 3 sekundy z efektem kolorowego podświetlenia.
- **Okresowe przypomnienia** - Jeśli użytkownik nie skorzystał z pomocy, przycisk ponownie pulsuje przez 3 sekundy co minutę, delikatnie przypominając o dostępności pomocy.
- **Zapamiętywanie interakcji** - System zapamiętuje, czy użytkownik skorzystał już z pomocy (wykorzystując localStorage), aby nie przeszkadzać doświadczonym użytkownikom.

```css
/* Animacja wjazdu przycisku pomocy od prawej strony */
@keyframes slide-in {
    0% { transform: translateX(100px); opacity: 0; }
    100% { transform: translateX(0); opacity: 1; }
}

/* Styl dla pulsującego przycisku pomocy */
@keyframes glow-pulse {
    0% { 
        box-shadow: 0 0 0 0 rgba(70, 130, 180, 0.9);
        transform: scale(1);
    }
    50% { 
        box-shadow: 0 0 25px 8px rgba(70, 130, 180, 0.8);
        transform: scale(1.15);
    }
    100% { 
        box-shadow: 0 0 0 0 rgba(220, 53, 69, 0.9);
        transform: scale(1);
    }
}

.help-button.slide-in {
    animation: slide-in 0.8s ease-out forwards;
}

.help-button.pulse {
    animation: glow-pulse 1.2s infinite ease-in-out;
    box-shadow: 0 0 20px 5px rgba(70, 130, 180, 0.8) !important;
}
```

2. **Modalne okna pomocy** - Dla każdego modułu zaimplementowano dedykowane okno modalne zawierające szczegółowe instrukcje:

```javascript
// Obsługa przycisków pomocy i okienek modalnych
document.addEventListener('DOMContentLoaded', function() {
    // Przyciski pomocy
    const helpAhpBtn = document.getElementById('help-ahp');
    const helpCuttingStockBtn = document.getElementById('help-cutting-stock');
    const helpProductionOptBtn = document.getElementById('help-production-opt');
    
    // Okienka modalne
    const helpModalAhp = document.getElementById('help-modal-ahp');
    const helpModalCuttingStock = document.getElementById('help-modal-cutting-stock');
    const helpModalProductionOpt = document.getElementById('help-modal-production-opt');
    
    // Przyciski zamykania okienek
    const closeButtons = document.querySelectorAll('.close-help-modal');
    
    // Funkcja otwierająca okienko modalne
    function openModal(modal) {
        if (modal) {
            modal.style.display = 'block';
            setTimeout(() => {
                modal.classList.add('show');
            }, 10);
        }
    }
    
    // Funkcja zamykająca okienko modalne
    function closeModal(modal) {
        if (modal) {
            modal.classList.remove('show');
            setTimeout(() => {
                modal.style.display = 'none';
            }, 300);
        }
    }
    
    // Obsługa kliknięć przycisków pomocy
    if (helpAhpBtn) {
        helpAhpBtn.addEventListener('click', () => openModal(helpModalAhp));
    }
    
    if (helpCuttingStockBtn) {
        helpCuttingStockBtn.addEventListener('click', () => openModal(helpModalCuttingStock));
    }
    
    if (helpProductionOptBtn) {
        helpProductionOptBtn.addEventListener('click', () => openModal(helpModalProductionOpt));
    }
    
    // Obsługa zamykania okienek modalnych
    closeButtons.forEach(button => {
        button.addEventListener('click', function() {
            const modal = this.closest('.help-modal');
            closeModal(modal);
        });
    });
    
    // Zamykanie okienka po kliknięciu poza nim
    window.addEventListener('click', function(event) {
        if (event.target.classList.contains('help-modal')) {
            closeModal(event.target);
        }
    });
});
```

3. **Zawartość pomocy** - Każde okno pomocy zawiera:
   - Ogólne wprowadzenie do danego narzędzia
   - Szczegółowe instrukcje korzystania z interfejsu
   - Wyjaśnienie kluczowych pojęć i parametrów
   - Wskazówki dotyczące interpretacji wyników
   - Informacje o ograniczeniach i najlepszych praktykach

### 4.4.2 Implementacja responsywnego interfejsu

Aplikacja została zaprojektowana z myślą o różnych urządzeniach, co wymagało implementacji responsywnego interfejsu:

1. **Adaptacyjna nawigacja boczna** - Menu boczne dostosowuje się do rozmiaru ekranu:

```css
/* Responsywność dostosowania dla tabeli szczegółów */
@media (max-width: 768px) {
    .diagnostics-info {
        grid-template-columns: 1fr;
    }
    
    #detailed-data {
        max-height: 300px;
    }
    
    /* Zwiększona szerokość nawy bocznej na urządzeniach mobilnych */
    .sidebar {
        width: 80%;
        min-width: 80%;
    }
    
    .sidebar-toggle {
        left: 80%;
        min-width: unset;
    }
    
    .main-content {
        width: 100%;
        margin-left: 0;
    }
}
```

2. **Optymalizacja menu głównego** - Na urządzeniach mobilnych menu główne wyświetla przyciski w jednym rzędzie:

```css
@media (max-width: 768px) {
    .container {
        max-width: 100%;
        margin: 0;
        padding: 10px;
        border-radius: 0;
        box-shadow: none;
    }

    .app-header h1 {
        font-size: 1.5rem;
        padding: 0 10px;
    }

    .app-nav ul {
        flex-direction: row;
        align-items: center;
        justify-content: center;
        flex-wrap: wrap;
        gap: 5px;
        padding: 5px;
    }

    .app-nav button {
        width: auto;
        padding: 8px 10px;
        margin: 0;
        font-size: 0.9rem;
    }
}
```

3. **Ikonograficzny przełącznik interfejsu** - Zastąpienie tekstowych etykiet ikonami w przełączniku interfejsu AHP:

```html
<!-- Przełącznik interfejsu -->
<div id="ahp-interface-switch" class="interface-switch-container">
    <div class="interface-switch">
        <label>Wybierz tryb interfejsu:</label>
        <div class="switch-options">
            <button id="matrix-interface" class="switch-option" title="Macierz porównań"><i class="fas fa-table"></i></button>
            <button id="simplified-interface" class="switch-option active" title="Uproszczony"><i class="fas fa-sliders-h"></i></button>
        </div>
    </div>
</div>
```

```css
.switch-option {
    padding: 8px 12px;
    font-size: 1em;
    background: none;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    transition: all 0.2s;
    margin: 0 2px;
    min-width: 40px;
}

.switch-option i {
    font-size: 1.2em;
}

.switch-option.active {
    background-color: var(--dark-brown);
    color: white;
    box-shadow: inset 0 1px 3px rgba(0,0,0,0.2);
}
```

4. **Dostosowanie formularzy** - Formularze wprowadzania danych zostały zoptymalizowane dla urządzeń mobilnych:

```css
@media (max-width: 768px) {
    .simplified-comparison-row {
        flex-direction: column;
        gap: 10px;
    }
    
    .criterion, .option {
        width: 100%;
    }
    
    .scale-container {
        width: 100%;
        margin: 10px 0;
    }
    
    .interface-switch-container {
        margin-left: 0 !important;
        margin-right: 0 !important;
        margin-top: 10px !important;
    }
    
    .interface-switch {
        width: 100%;
        justify-content: center;
    }
    
    .interface-switch label {
        display: none;
    }
    
    #tool-ahp .tool-header {
        flex-direction: column;
        align-items: flex-start;
    }
}
```

Dzięki powyższym implementacjom, aplikacja oferuje spójne doświadczenie użytkownika niezależnie od używanego urządzenia, a system pomocy kontekstowej skutecznie wspiera użytkowników w korzystaniu z zaawansowanych funkcji aplikacji. 